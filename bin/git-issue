#!/bin/bash
# git-issue: Issue tracking using git notes (or XDG directories) and hash-based IDs
# Supports both git repositories and standalone XDG directory storage

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Issue states and priorities
STATES=("open" "in-progress" "review" "done" "blocked")
PRIORITIES=("low" "medium" "high" "critical")

# Storage backend detection  
STORAGE_TYPE=""
ISSUE_REPO_DIR=""

# OPTIMIZED: Cached variables for performance
CACHED_USER_NAME=""
ORIGINAL_GIT_DIR=""

# Detect storage backend (git or XDG bare repo)
detect_storage_backend() {
    # Only use git mode if we have a local .git directory
    if [[ -d ".git" ]] || [[ -f ".git" ]]; then
        STORAGE_TYPE="git"
        echo -e "${BLUE}Using current git repository${NC}" >&2
    else
        STORAGE_TYPE="xdg"
        # Use platform-appropriate data directory with bare git repo
        local data_home
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS: Use Application Support
            data_home="${XDG_DATA_HOME:-$HOME/Library/Application Support}"
        else
            # Linux/Unix: Use XDG Base Directory specification
            data_home="${XDG_DATA_HOME:-$HOME/.local/share}"
        fi
        local project_name=$(basename "$(pwd)")
        ISSUE_REPO_DIR="$data_home/git-issue/$project_name.git"
        
        # Initialize bare git repo if it doesn't exist
        if [[ ! -d "$ISSUE_REPO_DIR" ]]; then
            echo -e "${YELLOW}Creating bare git repository for issue tracking: $ISSUE_REPO_DIR${NC}" >&2
            mkdir -p "$ISSUE_REPO_DIR"
            git init --bare "$ISSUE_REPO_DIR" >/dev/null 2>&1
            
            # Set up git environment temporarily to create initial commit
            local temp_git_dir="$GIT_DIR"
            export GIT_DIR="$ISSUE_REPO_DIR"
            
            # Create initial commit for notes to attach to
            local empty_tree="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
            local commit=$(echo "Initial commit for issue tracking" | git commit-tree "$empty_tree")
            git update-ref HEAD "$commit"
            
            # Restore git environment
            if [[ -n "$temp_git_dir" ]]; then
                export GIT_DIR="$temp_git_dir"
            else
                unset GIT_DIR
            fi
        fi
        
        # Set up git environment for XDG repo
        ORIGINAL_GIT_DIR="$GIT_DIR"
        export GIT_DIR="$ISSUE_REPO_DIR"
        echo -e "${YELLOW}Using standalone git repository: $ISSUE_REPO_DIR${NC}" >&2
    fi
}

# Clean up XDG git environment
cleanup_xdg_environment() {
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        if [[ -n "$ORIGINAL_GIT_DIR" ]]; then
            export GIT_DIR="$ORIGINAL_GIT_DIR"
        else
            unset GIT_DIR
        fi
    fi
}

# OPTIMIZED: Cache git user name for performance
get_git_user() {
    if [[ -z "$CACHED_USER_NAME" ]]; then
        CACHED_USER_NAME=$(git config user.name 2>/dev/null || echo "Unknown")
    fi
    echo "$CACHED_USER_NAME"
}

# Get storage path for issue (now always git refs)
get_issue_storage_path() {
    local id="$1"
    echo "refs/notes/issue-$id"
}

# Function to display usage
usage() {
    echo "Usage: git issue [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  create <title> [--description=<desc>]  Create new issue (auto-generates hash ID)"
    echo "  list                                    List all issues"
    echo "  show <id> [--with-commits]              Show issue details (optionally with related commits)"
    echo "  update <id> [--state=<state>] [--priority=<priority>] [--assignee=<assignee>] [--description=<desc>]  Update issue"
    echo "  comment <id> <text>                     Add comment to issue"
    echo "  link <id> <commit>                      Link issue to commit (git notes)"
    echo "  commit [--issue|--fixes|--closes] <id>  Add git trailer to commit"
    echo "  scan-commits [--since=<date>]           Scan commit trailers for issue references"
    echo "  import [--stdin|--file|--bulk] <files>  Import issues from various sources"
    echo "  export [--format=<fmt>] [<ids>]         Export issues (default: all)"
    echo "  dep add <from> <type> <to>              Add dependency (blocks, depends_on, parent_of, relates_to)"
    echo "  dep rm <from> <type> <to>               Remove dependency"
    echo "  dep list [<id>]                          List dependencies"
    echo "  ready                                    List issues ready to work on (sorted by priority)"
    echo "  topo                                     Topologically sorted ordering of non-done issues"
    echo "  deps [<id>] [--dot]                      Show dependency graph (text or Graphviz DOT)"
    echo "  setup-sync [enable|disable|status]     Configure automatic git notes sync"
    echo ""
    echo "Examples:"
    echo "  git issue create 'Add user authentication' --description='Implement OAuth2 login'"
    echo "  git issue update a1b2c3d --state=in-progress --priority=high"
    echo "  git issue update a1b2c3d --assignee='John Doe' --description='Updated requirements'"
    echo "  git issue comment a1b2c3d 'Started implementation'"
    echo "  git issue commit --fixes a1b2c3d      # Add trailer to HEAD commit"
    echo "  git issue show a1b2c3d --with-commits # Show issue with related commits"
    echo "  git issue scan-commits --since='1 week ago'  # Find issue references in commits"
    echo "  gh issue list --json number,title,body,state,author,createdAt,updatedAt,url | gh-to-git-issue | git issue import"
    echo ""
}

# Get issue note ref (legacy - use get_issue_storage_path)
get_issue_ref() {
    echo "refs/notes/issue-$1"
}

# Read issue data using git plumbing
read_issue_data() {
    local id="$1"
    local ref=$(get_issue_ref "$id")

    # Get the tree hash from the ref's commit
    local tree_hash
    tree_hash=$(git cat-file -p "$ref" 2>/dev/null | grep "^tree" | cut -d' ' -f2) || return 1

    # Tree should contain exactly one blob named "issue"
    local blob_hash
    blob_hash=$(git ls-tree "$tree_hash" 2>/dev/null | awk '$4 == "issue" {print $3}')

    if [[ -z "$blob_hash" ]]; then
        # Fallback: legacy format where blob is named after a commit SHA
        # If multiple blobs exist, take the first one (most recent is last in tree)
        blob_hash=$(git ls-tree "$tree_hash" 2>/dev/null | tail -1 | awk '{print $3}')
    fi

    [[ -z "$blob_hash" ]] && return 1
    git cat-file -p "$blob_hash" 2>/dev/null || return 1
}

# Write issue data using git plumbing (hash-object + mktree + commit-tree + update-ref)
write_issue_data() {
    local id="$1"
    local data="$2"
    local ref=$(get_issue_ref "$id")

    # Create blob from issue data
    local blob_hash
    blob_hash=$(echo "$data" | git hash-object -w --stdin)

    # Create tree with single entry named "issue"
    local tree_hash
    tree_hash=$(printf "100644 blob %s\tissue\n" "$blob_hash" | git mktree)

    # Create commit pointing to the tree (with parent if ref exists)
    local commit_hash
    local parent
    parent=$(git rev-parse --verify "$ref" 2>/dev/null) || true
    if [[ -n "$parent" ]]; then
        commit_hash=$(git commit-tree "$tree_hash" -p "$parent" -m "Update issue $id" </dev/null)
    else
        commit_hash=$(git commit-tree "$tree_hash" -m "Create issue $id" </dev/null)
    fi

    # Point the ref at the new commit
    git update-ref "$ref" "$commit_hash"
}

# List all issues (always git refs now)
list_all_issues() {
    git for-each-ref --format="%(refname)" 'refs/notes/issue-*' 2>/dev/null | sort
}

# Extract issue ID from storage reference (always git refs now)
extract_issue_id() {
    local ref="$1"
    echo "$ref" | sed 's/refs\/notes\/issue-//'
}

# Generate hash-based issue ID
generate_issue_id() {
    local title="$1"
    local author="$2"
    local timestamp="$3"
    
    # Create deterministic content for hashing
    local content="issue: $title
author: $author
created: $timestamp"
    
    # Generate git-style hash
    local hash=$(echo "$content" | git hash-object --stdin)
    
    # Use short version (7 characters, git default)
    echo "${hash:0:7}"
}

# Check if issue exists
issue_exists() {
    local id="$1"
    local ref=$(get_issue_ref "$id")
    # Check if the git ref exists
    git show-ref --verify --quiet "$ref"
}

# Parse front matter from issue data  
parse_front_matter() {
    local data="$1"
    echo "$data" | awk '/^---$/{p=1; next} /^---$/{p=0} !p && /^[a-z_]+:/ {print}'
}

# Parse comments from issue data
parse_comments() {
    local data="$1"
    echo "$data" | awk '/^---$/{p++; next} p>=2 {print}'
}

# Get field value from front matter
get_field_value() {
    local front_matter="$1"
    local field="$2"
    echo "$front_matter" | grep "^$field:" | cut -d' ' -f2- | xargs
}

# Create new issue with auto-generated hash ID
create_issue() {
    local title="$1"
    local description="$2"
    local author=$(get_git_user)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    # Generate hash ID
    local id=$(generate_issue_id "$title" "$author" "$timestamp")
    
    # Check for conflicts (rare but possible)
    local attempts=0
    while issue_exists "$id" && [[ $attempts -lt 100 ]]; do
        echo "‚ö†Ô∏è  Hash collision detected for $id, regenerating..."
        # Add microsecond precision to avoid collision
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
        id=$(generate_issue_id "$title" "$author" "$timestamp")
        ((attempts++))
    done
    
    if [[ $attempts -ge 100 ]]; then
        echo -e "${RED}Unable to generate unique ID after 100 attempts${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Creating issue with hash ID: $id${NC}"
    
    # Create issue data (only include non-empty fields)
    local issue_data="id: $id
title: $title"
    [[ -n "$description" ]] && issue_data="$issue_data
description: $description"
    issue_data="$issue_data
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee: $author
hash_source: content
---"
    
    write_issue_data "$id" "$issue_data"
    
    echo -e "${GREEN}‚úì Created issue #$id: $title${NC}"
    echo -e "${GRAY}   Use this ID for future operations: $id${NC}"
}

# List all issues
list_issues() {
    echo -e "${BLUE}Issues:${NC}"
    echo ""
    
    # Find all issue refs
    for ref in $(list_all_issues); do
        id=$(extract_issue_id "$ref")
        if data=$(read_issue_data "$id" 2>/dev/null); then
            # Extract key fields
            title=$(echo "$data" | grep "^title:" | cut -d' ' -f2-)
            state=$(echo "$data" | grep "^state:" | cut -d' ' -f2)
            priority=$(echo "$data" | grep "^priority:" | cut -d' ' -f2)
            assignee=$(echo "$data" | grep "^assignee:" | cut -d' ' -f2-)
            
            # Color based on state
            case "$state" in
                done) color=$GRAY ;;
                blocked) color=$RED ;;
                in-progress) color=$YELLOW ;;
                review) color=$BLUE ;;
                *) color=$NC ;;
            esac
            
            # Format output
            echo -ne "${color}#${id} [${state}] ${title} (P: ${priority})"
            [ -n "$assignee" ] && echo -n " ‚Üí $assignee"
            echo -e "${NC}"
        fi
    done
}

# Show issue details
show_issue() {
    local id="$1"
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! issue_exists "$id"; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local data=$(read_issue_data "$id")
    local front_matter=$(parse_front_matter "$data")
    local comments=$(parse_comments "$data")
    
    # Extract fields
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local github_id=$(get_field_value "$front_matter" "github_id")
    local github_url=$(get_field_value "$front_matter" "github_url")
    local jira_id=$(get_field_value "$front_matter" "jira_id")
    local jira_url=$(get_field_value "$front_matter" "jira_url")
    local gitlab_id=$(get_field_value "$front_matter" "gitlab_id")
    local gitlab_url=$(get_field_value "$front_matter" "gitlab_url")
    local state=$(get_field_value "$front_matter" "state")
    local priority=$(get_field_value "$front_matter" "priority")
    local created=$(get_field_value "$front_matter" "created")
    local updated=$(get_field_value "$front_matter" "updated")
    local author=$(get_field_value "$front_matter" "author")
    local assignee=$(get_field_value "$front_matter" "assignee")
    local blocks=$(get_field_value "$front_matter" "blocks")
    local depends_on=$(get_field_value "$front_matter" "depends_on")
    local parent_of=$(get_field_value "$front_matter" "parent_of")
    local relates_to=$(get_field_value "$front_matter" "relates_to")

    # Display issue
    echo -e "${BOLD}Issue #$id${NC}"
    echo "============"
    echo "Title: $title"
    [[ -n "$description" ]] && echo "Description: $description"
    
    # Show external provider links
    [[ -n "$github_id" ]] && echo "GitHub: #$github_id ($github_url)"
    [[ -n "$jira_id" ]] && echo "Jira: $jira_id ($jira_url)"
    [[ -n "$gitlab_id" ]] && echo "GitLab: #$gitlab_id ($gitlab_url)"
    
    echo "State: $state"
    echo "Priority: $priority"
    echo "Author: $author"
    [[ -n "$assignee" ]] && echo "Assignee: $assignee"
    [[ -n "$blocks" ]] && echo "Blocks: $blocks"
    [[ -n "$depends_on" ]] && echo "Depends on: $depends_on"
    [[ -n "$parent_of" ]] && echo "Parent of: $parent_of"
    [[ -n "$relates_to" ]] && echo "Relates to: $relates_to"
    echo "Created: $created"
    echo "Updated: $updated"
    
    if [[ -n "$comments" ]]; then
        echo ""
        echo "Comments:"
        echo "---------"
        echo "$comments"
    fi
}

# Update issue field
update_issue() {
    local id=$1
    local field=$2
    local value="${@:3}"
    local ref=$(get_issue_ref "$id")
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate field
    case "$field" in
        state)
            if [[ ! " ${STATES[*]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid state: $value${NC}"
                echo "Valid states: ${STATES[*]}"
                return 1
            fi
            ;;
        priority)
            if [[ ! " ${PRIORITIES[*]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid priority: $value${NC}"
                echo "Valid priorities: ${PRIORITIES[*]}"
                return 1
            fi
            ;;
        assignee)
            # Accept any value for assignee
            ;;
        description)
            # Accept any value for description
            ;;
        blocks|depends_on|parent_of|relates_to)
            # Accept comma-separated issue IDs
            ;;
        *)
            echo -e "${RED}Invalid field: $field${NC}"
            echo "Valid fields: state, priority, assignee, description, blocks, depends_on, parent_of, relates_to"
            return 1
            ;;
    esac
    
    # Get current data
    data=$(read_issue_data "$id")
    
    # Update the field
    updated_data=$(echo "$data" | awk -v field="$field:" -v value="$value" -v ts="$timestamp" '
        BEGIN { found=0; in_body=0 }
        /^---$/ { if (!found) { print field, value; found=1 }; in_body=1; print; next }
        in_body { print; next }
        $1 == field { print field, value; found=1; next }
        $1 == "updated:" { print "updated:", ts; next }
        { print }
    ')
    
    # Save updated data
    write_issue_data "$id" "$updated_data"
}

# Update issue using git-style flags
update_issue_with_flags() {
    local id="$1"
    shift
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local state="" priority="" assignee="" description=""
    local blocks="" depends_on="" parent_of="" relates_to=""
    local has_updates=false
    
    # Parse git-style flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state=*)
                state="${1#*=}"
                has_updates=true
                ;;
            --priority=*)
                priority="${1#*=}"
                has_updates=true
                ;;
            --assignee=*)
                assignee="${1#*=}"
                has_updates=true
                ;;
            --description=*)
                description="${1#*=}"
                has_updates=true
                ;;
            --blocks=*)
                blocks="${1#*=}"
                has_updates=true
                ;;
            --depends-on=*)
                depends_on="${1#*=}"
                has_updates=true
                ;;
            --parent-of=*)
                parent_of="${1#*=}"
                has_updates=true
                ;;
            --relates-to=*)
                relates_to="${1#*=}"
                has_updates=true
                ;;
            --state|--priority|--assignee|--description|--blocks|--depends-on|--parent-of|--relates-to)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: $1 requires a value${NC}" >&2
                    return 1
                fi
                case "$1" in
                    --state) state="$2"; has_updates=true ;;
                    --priority) priority="$2"; has_updates=true ;;
                    --assignee) assignee="$2"; has_updates=true ;;
                    --description) description="$2"; has_updates=true ;;
                    --blocks) blocks="$2"; has_updates=true ;;
                    --depends-on) depends_on="$2"; has_updates=true ;;
                    --parent-of) parent_of="$2"; has_updates=true ;;
                    --relates-to) relates_to="$2"; has_updates=true ;;
                esac
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --state, --priority, --assignee, --description, --blocks, --depends-on, --parent-of, --relates-to" >&2
                return 1
                ;;
        esac
        shift
    done
    
    if [[ "$has_updates" == "false" ]]; then
        echo -e "${RED}Error: No update flags provided${NC}" >&2
        echo "Use --state, --priority, --assignee, --description, --blocks, --depends-on, --parent-of, or --relates-to" >&2
        return 1
    fi
    
    # Validate values
    if [[ -n "$state" ]]; then
        case "$state" in
            "open"|"in-progress"|"review"|"done"|"blocked") ;;
            *) echo -e "${RED}Error: Invalid state '$state'${NC}" >&2
               echo "Valid states: open, in-progress, review, done, blocked" >&2
               return 1 ;;
        esac
    fi
    
    if [[ -n "$priority" ]]; then
        case "$priority" in
            "low"|"medium"|"high"|"critical") ;;
            *) echo -e "${RED}Error: Invalid priority '$priority'${NC}" >&2
               echo "Valid priorities: low, medium, high, critical" >&2
               return 1 ;;
        esac
    fi
    
    # Update using legacy function for each field
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local changes=""
    
    if [[ -n "$state" ]]; then
        update_issue "$id" "state" "$state"
        changes="state=$state "
        if [[ "$state" == "done" ]]; then
            cascade_unblock "$id"
        fi
    fi
    if [[ -n "$priority" ]]; then
        update_issue "$id" "priority" "$priority"
        changes="${changes}priority=$priority "
    fi
    if [[ -n "$assignee" ]]; then
        update_issue "$id" "assignee" "$assignee"
        changes="${changes}assignee=$assignee "
    fi
    if [[ -n "$description" ]]; then
        update_issue "$id" "description" "$description"
        changes="${changes}description=updated "
    fi
    if [[ -n "$blocks" ]]; then
        update_issue "$id" "blocks" "$blocks"
        changes="${changes}blocks=$blocks "
    fi
    if [[ -n "$depends_on" ]]; then
        update_issue "$id" "depends_on" "$depends_on"
        changes="${changes}depends_on=$depends_on "
    fi
    if [[ -n "$parent_of" ]]; then
        update_issue "$id" "parent_of" "$parent_of"
        changes="${changes}parent_of=$parent_of "
    fi
    if [[ -n "$relates_to" ]]; then
        update_issue "$id" "relates_to" "$relates_to"
        changes="${changes}relates_to=$relates_to "
    fi

    echo -e "${GREEN}‚úì Updated issue #$id: ${changes}${NC}"
}

# Create issue with git-style flags
create_issue_with_flags() {
    local title=""
    local description=""
    
    # Parse arguments for title and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --description=*)
                description="${1#*=}"
                ;;
            --description)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: --description requires a value${NC}" >&2
                    return 1
                fi
                description="$2"
                shift
                ;;
            --*)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --description" >&2
                return 1
                ;;
            *)
                if [[ -z "$title" ]]; then
                    title="$1"
                else
                    echo -e "${RED}Error: Multiple titles provided. Use quotes for titles with spaces.${NC}" >&2
                    return 1
                fi
                ;;
        esac
        shift
    done
    
    if [[ -z "$title" ]]; then
        echo -e "${RED}Error: Issue title is required${NC}" >&2
        echo "Usage: git issue create 'Title' [--description='Description']" >&2
        return 1
    fi
    
    create_issue "$title" "$description"
}

# Setup automatic git notes synchronization
setup_sync() {
    local action="${1:-enable}"
    
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Auto-sync is only available in git repositories, not XDG mode${NC}"
        return 1
    fi
    
    case "$action" in
        enable)
            setup_sync_enable
            ;;
        disable)
            setup_sync_disable
            ;;
        status)
            setup_sync_status
            ;;
        *)
            echo "Usage: git issue setup-sync [enable|disable|status]"
            echo ""
            echo "Commands:"
            echo "  enable   Install git hooks for automatic notes sync"
            echo "  disable  Remove git hooks and disable auto-sync"
            echo "  status   Show current sync configuration"
            return 1
            ;;
    esac
}

# Enable automatic sync
setup_sync_enable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    local script_dir="$(dirname "$(realpath "$0")")"
    
    echo -e "${BLUE}üîß Setting up automatic git notes synchronization...${NC}"
    
    # Create hooks directory if it doesn't exist
    mkdir -p "$hooks_dir"
    
    # Install post-merge hook
    if [[ -f "$hooks_dir/post-merge" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Existing post-merge hook found, backing up to post-merge.backup${NC}"
        mv "$hooks_dir/post-merge" "$hooks_dir/post-merge.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/post-merge" ]]; then
        cp "$script_dir/../hooks/post-merge" "$hooks_dir/post-merge"
        chmod +x "$hooks_dir/post-merge"
        echo -e "${GREEN}‚úì Installed post-merge hook (auto-fetch notes)${NC}"
    else
        echo -e "${RED}‚ùå Could not find post-merge hook template${NC}"
        return 1
    fi
    
    # Install pre-push hook
    if [[ -f "$hooks_dir/pre-push" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Existing pre-push hook found, backing up to pre-push.backup${NC}"
        mv "$hooks_dir/pre-push" "$hooks_dir/pre-push.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/pre-push" ]]; then
        cp "$script_dir/../hooks/pre-push" "$hooks_dir/pre-push"
        chmod +x "$hooks_dir/pre-push"
        echo -e "${GREEN}‚úì Installed pre-push hook (auto-push notes)${NC}"
    else
        echo -e "${RED}‚ùå Could not find pre-push hook template${NC}"
        return 1
    fi
    
    # Enable sync in git config
    git config git-issue.sync.enabled true
    echo -e "${GREEN}‚úì Enabled automatic notes sync in git config${NC}"
    
    # Configure automatic notes fetching
    git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*' 2>/dev/null || true
    echo -e "${GREEN}‚úì Configured automatic notes fetching${NC}"
    
    echo ""
    echo -e "${GREEN}üéâ Automatic git notes sync is now enabled!${NC}"
    echo ""
    echo "Your issue notes will now:"
    echo "  ‚Ä¢ Auto-fetch when you pull/merge"
    echo "  ‚Ä¢ Auto-push when you push commits"
    echo ""
    echo "To disable: git issue setup-sync disable"
}

# Disable automatic sync
setup_sync_disable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}üîß Disabling automatic git notes synchronization...${NC}"
    
    # Remove hooks (restore backups if they exist)
    if [[ -f "$hooks_dir/post-merge" ]]; then
        if [[ -f "$hooks_dir/post-merge.backup" ]]; then
            mv "$hooks_dir/post-merge.backup" "$hooks_dir/post-merge"
            echo -e "${GREEN}‚úì Restored original post-merge hook${NC}"
        else
            rm "$hooks_dir/post-merge"
            echo -e "${GREEN}‚úì Removed post-merge hook${NC}"
        fi
    fi
    
    if [[ -f "$hooks_dir/pre-push" ]]; then
        if [[ -f "$hooks_dir/pre-push.backup" ]]; then
            mv "$hooks_dir/pre-push.backup" "$hooks_dir/pre-push"
            echo -e "${GREEN}‚úì Restored original pre-push hook${NC}"
        else
            rm "$hooks_dir/pre-push"
            echo -e "${GREEN}‚úì Removed pre-push hook${NC}"
        fi
    fi
    
    # Disable sync in git config
    git config git-issue.sync.enabled false
    echo -e "${GREEN}‚úì Disabled automatic notes sync in git config${NC}"
    
    echo ""
    echo -e "${GREEN}‚úì Automatic git notes sync has been disabled${NC}"
    echo ""
    echo "You can manually sync notes with:"
    echo "  git fetch origin 'refs/notes/*:refs/notes/*'"
    echo "  git push origin 'refs/notes/issue-*'"
}

# Show sync status
setup_sync_status() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}Git Notes Sync Status${NC}"
    echo "===================="
    
    # Check configuration
    local sync_enabled=$(git config --get git-issue.sync.enabled 2>/dev/null || echo "false")
    echo "Config enabled: $sync_enabled"
    
    # Check hooks
    local post_merge_exists="‚ùå"
    local pre_push_exists="‚ùå"
    
    if [[ -f "$hooks_dir/post-merge" && -x "$hooks_dir/post-merge" ]]; then
        post_merge_exists="‚úÖ"
    fi
    
    if [[ -f "$hooks_dir/pre-push" && -x "$hooks_dir/pre-push" ]]; then
        pre_push_exists="‚úÖ"
    fi
    
    echo "Post-merge hook: $post_merge_exists"
    echo "Pre-push hook: $pre_push_exists"
    
    # Check notes refs configuration
    local notes_fetch_configured="‚ùå"
    if git config --get-regexp "remote\..*\.fetch" | grep -q "refs/notes"; then
        notes_fetch_configured="‚úÖ"
    fi
    echo "Notes auto-fetch: $notes_fetch_configured"
    
    # Count existing notes
    local note_count=$(git for-each-ref --format="%(refname)" refs/notes/issue-* 2>/dev/null | wc -l)
    echo "Issue notes: $note_count"
    
    echo ""
    if [[ "$sync_enabled" == "true" && "$post_merge_exists" == "‚úÖ" && "$pre_push_exists" == "‚úÖ" ]]; then
        echo -e "${GREEN}‚úì Automatic sync is fully configured and enabled${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Automatic sync is not fully configured${NC}"
        echo "Run: git issue setup-sync enable"
    fi
}

# Import issues from various sources
import_issues() {
    local source="stdin"
    local format="auto"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --stdin)
                source="stdin"
                shift
                ;;
            --file)
                source="$2"
                shift 2
                ;;
            --bulk)
                source="bulk"
                shift
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                break
                ;;
        esac
    done
    
    case "$source" in
        stdin)
            import_from_stdin "$format"
            ;;
        bulk)
            import_bulk_files "$@"
            ;;
        *)
            import_from_file "$source" "$format"
            ;;
    esac
}

# Import from stdin
import_from_stdin() {
    local format="$1"
    local count=0
    
    echo -e "${BLUE}üì• Importing issues from stdin...${NC}" >&2
    
    # Read issue data blocks separated by blank lines
    local issue_data=""
    while IFS= read -r line; do
        if [[ -z "$line" && -n "$issue_data" ]]; then
            # Process complete issue
            if import_single_issue "$issue_data"; then
                ((count++))
            fi
            issue_data=""
        else
            issue_data="$issue_data$line"$'\n'
        fi
    done
    
    # Process final issue if exists
    if [[ -n "$issue_data" ]]; then
        if import_single_issue "$issue_data"; then
            ((count++))
        fi
    fi
    
    echo -e "${GREEN}‚úì Imported $count issues${NC}" >&2
}

# Import from file
import_from_file() {
    local file="$1"
    local format="$2"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        return 1
    fi
    
    echo -e "${BLUE}üì• Importing issues from $file...${NC}" >&2
    cat "$file" | import_from_stdin "$format"
}

# Import bulk files
import_bulk_files() {
    local count=0
    local total=0
    
    echo -e "${BLUE}üì• Importing issues from multiple files...${NC}" >&2
    
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            echo -e "${YELLOW}Processing $file...${NC}" >&2
            ((total++))
            if import_from_file "$file" "auto" >&2; then
                ((count++))
            fi
        else
            echo -e "${RED}Warning: File not found: $file${NC}" >&2
        fi
    done
    
    echo -e "${GREEN}‚úì Processed $count/$total files${NC}" >&2
}

# Import a single issue from data
import_single_issue() {
    local data="$1"
    
    # Extract ID and validate format
    local id=$(echo "$data" | grep "^id:" | cut -d' ' -f2- | xargs)
    if [[ -z "$id" ]]; then
        echo -e "${RED}Warning: Issue data missing ID, skipping${NC}" >&2
        return 1
    fi
    
    # Check if issue already exists
    if issue_exists "$id"; then
        echo -e "${YELLOW}Warning: Issue #$id already exists, skipping${NC}" >&2
        return 1
    fi
    
    # Write issue data
    if write_issue_data "$id" "$data"; then
        local title=$(echo "$data" | grep "^title:" | cut -d' ' -f2- | xargs)
        echo -e "${GREEN}‚úì Imported issue #$id: $title${NC}" >&2
        return 0
    else
        echo -e "${RED}Failed to import issue #$id${NC}" >&2
        return 1
    fi
}

# Export issues to various formats
export_issues() {
    local format="git-issue"
    local output="stdout"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --github)
                format="github"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get issues to export (IDs or all)
    local issue_ids=("$@")
    if [[ ${#issue_ids[@]} -eq 0 ]]; then
        # Export all issues
        local refs=($(list_all_issues))
        for ref in "${refs[@]}"; do
            local id=$(get_issue_id_from_ref "$ref")
            issue_ids+=("$id")
        done
    fi
    
    echo -e "${BLUE}üì§ Exporting ${#issue_ids[@]} issues...${NC}" >&2
    
    for id in "${issue_ids[@]}"; do
        if ! issue_exists "$id"; then
            echo -e "${RED}Warning: Issue #$id not found, skipping${NC}" >&2
            continue
        fi
        
        local data=$(read_issue_data "$id")
        
        case "$format" in
            github)
                export_to_github_format "$data"
                ;;
            git-issue|*)
                echo "$data"
                echo ""  # Separator between issues
                ;;
        esac
    done
}

# Export to GitHub-compatible format (for gh CLI)
export_to_github_format() {
    local data="$1"
    local front_matter=$(parse_front_matter "$data")
    
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local state=$(get_field_value "$front_matter" "state")
    local labels=$(get_field_value "$front_matter" "labels")
    
    # Map git-issue state to GitHub state
    local gh_state="open"
    case "$state" in
        done|closed) gh_state="closed" ;;
    esac
    
    # Output GitHub CLI compatible format
    cat << EOF
{
  "title": "$title",
  "body": "$description",
  "state": "$gh_state",
  "labels": [$(echo "$labels" | sed 's/,/", "/g' | sed 's/^/"/; s/$/"/' | sed 's/""//g')]
}
EOF
}

# Add comment to issue
add_comment() {
    local id=$1
    local comment="${@:2}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local author=$(get_git_user)
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Get current data and append comment
    data=$(read_issue_data "$id")
    updated_data="$data

[$timestamp] $author: $comment"
    
    write_issue_data "$id" "$updated_data"
    
    echo -e "${GREEN}‚úì Added comment to issue #$id${NC}"
}

# Link issue to commit
link_issue() {
    local id=$1
    local commit=$2
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate commit
    if ! git rev-parse "$commit" >/dev/null 2>&1; then
        echo -e "${RED}Invalid commit: $commit${NC}"
        return 1
    fi
    
    commit_hash=$(git rev-parse --short "$commit")
    
    # Add link as comment
    add_comment "$id" "Linked to commit: $commit_hash"
    
    # Note functionality is integrated into git-issue
}

# ==========================================
# GIT TRAILERS INTEGRATION FUNCTIONS
# ==========================================

# Parse issue trailers from commit message
parse_issue_trailers() {
    local commit="$1"
    if [[ -z "$commit" ]]; then
        echo -e "${RED}Error: Commit hash required${NC}" >&2
        return 1
    fi
    
    # Get commit message and parse trailers
    git show --format="%B" -s "$commit" 2>/dev/null | \
        git interpret-trailers --parse 2>/dev/null | \
        grep -E "^(Issue|Fixes|Closes|Related-To):" || true
}

# Add trailer to commit message (creates new commit with trailer)
add_issue_trailer() {
    local commit="$1"
    local trailer_type="$2"  # issue, fixes, closes, related-to
    local issue_id="$3"
    
    if [[ -z "$commit" || -z "$trailer_type" || -z "$issue_id" ]]; then
        echo -e "${RED}Error: add_issue_trailer requires commit, trailer_type, and issue_id${NC}" >&2
        return 1
    fi
    
    # Validate commit exists
    if ! git rev-parse "$commit" >/dev/null 2>&1; then
        echo -e "${RED}Error: Invalid commit: $commit${NC}" >&2
        return 1
    fi
    
    # Format trailer key
    local trailer_key
    case "$trailer_type" in
        issue) trailer_key="Issue" ;;
        fixes) trailer_key="Fixes" ;;
        closes) trailer_key="Closes" ;;
        related-to) trailer_key="Related-To" ;;
        *) 
            echo -e "${RED}Error: Invalid trailer type: $trailer_type${NC}" >&2
            echo "Valid types: issue, fixes, closes, related-to" >&2
            return 1
            ;;
    esac
    
    # Get current commit message
    local commit_msg
    commit_msg=$(git show --format="%B" -s "$commit")
    
    # Add trailer to message
    local new_msg
    new_msg=$(echo "$commit_msg" | git interpret-trailers --trailer "${trailer_key}: #${issue_id}")
    
    echo -e "${GREEN}Trailer added: ${trailer_key}: #${issue_id}${NC}"
    echo -e "${YELLOW}Note: This would modify commit $commit${NC}"
    echo -e "${YELLOW}Use git commit --amend to apply changes interactively${NC}"
}

# Scan commit history for issue references
scan_commits_for_issues() {
    local since="${1:-}"
    local format="${2:-summary}"
    
    echo -e "${BLUE}üîç Scanning commits for issue references...${NC}"
    echo ""
    
    # Build git log arguments
    local git_log_args=("--oneline")
    if [[ -n "$since" ]]; then
        git_log_args+=("--since=$since")
    fi
    
    # Get commit hashes
    local commit_count=0
    local issue_refs_found=0
    
    git log "${git_log_args[@]}" --format="%H %s" | while IFS=' ' read -r commit_hash commit_subject; do
        commit_count=$((commit_count + 1))
        
        # Parse trailers from this commit
        local trailers
        trailers=$(parse_issue_trailers "$commit_hash")
        
        if [[ -n "$trailers" ]]; then
            issue_refs_found=$((issue_refs_found + 1))
            
            if [[ "$format" == "detailed" ]]; then
                echo -e "${GREEN}Commit: ${commit_hash:0:7}${NC} - $commit_subject"
                echo "$trailers" | while IFS= read -r trailer; do
                    echo "  $trailer"
                done
                echo ""
            else
                # Summary format
                echo "$trailers" | while IFS= read -r trailer; do
                    local issue_id=$(echo "$trailer" | grep -o '#[a-f0-9]\{7\}' | sed 's/#//')
                    local trailer_type=$(echo "$trailer" | cut -d':' -f1)
                    echo "${commit_hash:0:7} $trailer_type: #$issue_id"
                done
            fi
        fi
    done
    
    if [[ $issue_refs_found -eq 0 ]]; then
        echo -e "${YELLOW}No issue references found in commit trailers${NC}"
        echo -e "${GRAY}Tip: Use 'git issue commit --fixes <id>' to add trailers to commits${NC}"
    fi
}

# Get commits related to an issue (by scanning trailers)
get_related_commits() {
    local issue_id="$1"
    
    if [[ -z "$issue_id" ]]; then
        echo -e "${RED}Error: Issue ID required${NC}" >&2
        return 1
    fi
    
    # Scan all commits for references to this issue
    git log --oneline --format="%H" | while read -r commit_hash; do
        local trailers
        trailers=$(parse_issue_trailers "$commit_hash" 2>/dev/null || true)
        
        if echo "$trailers" | grep -q "#$issue_id"; then
            # Found a reference to this issue
            local commit_subject
            commit_subject=$(git show --format="%s" -s "$commit_hash")
            local trailer_types
            trailer_types=$(echo "$trailers" | grep "#$issue_id" | cut -d':' -f1 | tr '\n' ',' | sed 's/,$//')
            
            echo "${commit_hash:0:7} [$trailer_types] $commit_subject"
        fi
    done
}

# Handle git issue commit command with trailers
handle_commit_with_trailers() {
    local issue_id=""
    local trailer_type="issue"
    local commit="HEAD"
    local show_help=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --issue)
                trailer_type="issue"
                issue_id="$2"
                shift 2
                ;;
            --fixes)
                trailer_type="fixes" 
                issue_id="$2"
                shift 2
                ;;
            --closes)
                trailer_type="closes"
                issue_id="$2"
                shift 2
                ;;
            --related-to)
                trailer_type="related-to"
                issue_id="$2"
                shift 2
                ;;
            --commit)
                commit="$2"
                shift 2
                ;;
            --help|-h)
                show_help=true
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown option '$1'${NC}" >&2
                show_help=true
                break
                ;;
        esac
    done
    
    if [[ "$show_help" == true ]] || [[ -z "$issue_id" ]]; then
        echo "Usage: git issue commit [OPTIONS]"
        echo ""
        echo "Add issue trailers to git commits for standardized issue tracking"
        echo ""
        echo "Options:"
        echo "  --issue <id>      Link commit to issue (default)"
        echo "  --fixes <id>      Mark issue as fixed by this commit"
        echo "  --closes <id>     Mark issue as closed by this commit" 
        echo "  --related-to <id> Reference related issue"
        echo "  --commit <hash>   Target commit (default: HEAD)"
        echo "  --help, -h        Show this help"
        echo ""
        echo "Examples:"
        echo "  git issue commit --fixes a1b2c3d"
        echo "  git issue commit --issue b2c3d4e --commit abc1234"
        echo "  git issue commit --closes c3d4e5f"
        return 1
    fi
    
    # Validate issue exists
    if ! issue_exists "$issue_id"; then
        echo -e "${RED}Error: Issue #$issue_id not found${NC}" >&2
        return 1
    fi
    
    # Add trailer
    add_issue_trailer "$commit" "$trailer_type" "$issue_id"
    
    # If this is a fixes/closes trailer, update the issue state
    if [[ "$trailer_type" == "fixes" || "$trailer_type" == "closes" ]]; then
        echo ""
        echo -e "${YELLOW}Updating issue state...${NC}"
        update_issue "$issue_id" state done
        
        # Add comment about the commit
        local commit_short=$(git rev-parse --short "$commit")
        local commit_subject=$(git show --format="%s" -s "$commit")
        add_comment "$issue_id" "Resolved by commit $commit_short: $commit_subject"
    elif [[ "$trailer_type" == "issue" || "$trailer_type" == "related-to" ]]; then
        # Add comment about the link
        local commit_short=$(git rev-parse --short "$commit")  
        local commit_subject=$(git show --format="%s" -s "$commit")
        add_comment "$issue_id" "Referenced in commit $commit_short: $commit_subject"
    fi
}

# ==========================================
# DEPENDENCY MANAGEMENT FUNCTIONS
# ==========================================

# ==========================================
# EDGE INDEX (refs/notes/dep-graph)
# ==========================================

# Read the edge index from refs/notes/dep-graph
read_edge_index() {
    local ref="refs/notes/dep-graph"
    local tree_hash
    tree_hash=$(git cat-file -p "$ref" 2>/dev/null | grep "^tree" | cut -d' ' -f2)
    if [[ -z "$tree_hash" ]]; then
        echo ""
        return 0
    fi
    local blob_hash
    blob_hash=$(git ls-tree "$tree_hash" 2>/dev/null | awk '$4 == "edges" {print $3}')
    if [[ -z "$blob_hash" ]]; then
        # Fallback: legacy format
        blob_hash=$(git ls-tree "$tree_hash" 2>/dev/null | tail -1 | awk '{print $3}')
    fi
    if [[ -z "$blob_hash" ]]; then
        echo ""
        return 0
    fi
    git cat-file -p "$blob_hash" 2>/dev/null || echo ""
}

# Write content to the edge index using git plumbing
write_edge_index() {
    local data="$1"
    local ref="refs/notes/dep-graph"

    local blob_hash
    blob_hash=$(echo "$data" | git hash-object -w --stdin)

    local tree_hash
    tree_hash=$(printf "100644 blob %s\tedges\n" "$blob_hash" | git mktree)

    local commit_hash
    local parent
    parent=$(git rev-parse --verify "$ref" 2>/dev/null) || true
    if [[ -n "$parent" ]]; then
        commit_hash=$(git commit-tree "$tree_hash" -p "$parent" -m "Update edge index" </dev/null)
    else
        commit_hash=$(git commit-tree "$tree_hash" -m "Create edge index" </dev/null)
    fi

    git update-ref "$ref" "$commit_hash"
}

# Add an edge to the index (deduplicates)
add_edge() {
    local from="$1"
    local type="$2"
    local to="$3"
    local line="$from $type $to"

    local current
    current=$(read_edge_index)

    # Check for duplicate
    if echo "$current" | grep -qF "$line"; then
        return 0
    fi

    if [[ -z "$current" ]]; then
        write_edge_index "$line"
    else
        write_edge_index "${current}"$'\n'"${line}"
    fi
}

# Remove an edge from the index
remove_edge() {
    local from="$1"
    local type="$2"
    local to="$3"
    local line="$from $type $to"

    local current
    current=$(read_edge_index)

    if [[ -z "$current" ]]; then
        return 0
    fi

    local updated
    updated=$(echo "$current" | grep -vF "$line" || true)

    if [[ -z "$updated" ]]; then
        git update-ref -d "refs/notes/dep-graph" 2>/dev/null || true
    else
        write_edge_index "$updated"
    fi
}

# Rebuild the entire edge index from issue headers
rebuild_edge_index() {
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local edges="last_rebuilt_from: $timestamp"

    for ref in $(list_all_issues); do
        local id
        id=$(extract_issue_id "$ref")
        local data
        data=$(read_issue_data "$id" 2>/dev/null) || continue
        local front_matter
        front_matter=$(parse_front_matter "$data")

        local blocks depends_on parent_of relates_to

        blocks=$(get_field_value "$front_matter" "blocks")
        depends_on=$(get_field_value "$front_matter" "depends_on")
        parent_of=$(get_field_value "$front_matter" "parent_of")
        relates_to=$(get_field_value "$front_matter" "relates_to")

        if [[ -n "$blocks" ]]; then
            local IFS=','
            for target in $blocks; do
                target=$(echo "$target" | xargs)
                edges="${edges}"$'\n'"${id} blocks ${target}"
            done
            unset IFS
        fi
        if [[ -n "$depends_on" ]]; then
            local IFS=','
            for target in $depends_on; do
                target=$(echo "$target" | xargs)
                edges="${edges}"$'\n'"${id} depends_on ${target}"
            done
            unset IFS
        fi
        if [[ -n "$parent_of" ]]; then
            local IFS=','
            for target in $parent_of; do
                target=$(echo "$target" | xargs)
                edges="${edges}"$'\n'"${id} parent_of ${target}"
            done
            unset IFS
        fi
        if [[ -n "$relates_to" ]]; then
            local IFS=','
            for target in $relates_to; do
                target=$(echo "$target" | xargs)
                edges="${edges}"$'\n'"${id} relates_to ${target}"
            done
            unset IFS
        fi
    done

    write_edge_index "$edges"
    echo -e "${GREEN}Edge index rebuilt at $timestamp${NC}"
}

# Incremental rebuild: check if any issue notes have changed since the
# last edge index rebuild, re-parse only those issues, and update the
# edge index.  Called before graph queries to keep the index current
# when headers are edited outside of dep add/rm (manual edits, imports).
ensure_edge_index_current() {
    local edge_data
    edge_data=$(read_edge_index)

    # Get the last rebuild timestamp from the index
    local last_rebuilt
    last_rebuilt=$(echo "$edge_data" | grep "^last_rebuilt_from:" | cut -d' ' -f2-)

    # Find issue notes modified since last rebuild
    local needs_rebuild=false
    local changed_ids=()

    for ref in $(git for-each-ref --format="%(refname)" 'refs/notes/issue-*' 2>/dev/null); do
        local ref_date
        ref_date=$(git for-each-ref --format="%(committerdate:iso-strict)" "$ref" 2>/dev/null)
        if [[ -z "$last_rebuilt" ]] || [[ "$ref_date" > "$last_rebuilt" ]]; then
            local id
            id=$(echo "$ref" | sed 's/refs\/notes\/issue-//')
            changed_ids+=("$id")
            needs_rebuild=true
        fi
    done

    if [[ "$needs_rebuild" == "true" ]]; then
        # Re-parse only changed issues and update edges
        for id in "${changed_ids[@]}"; do
            local data
            data=$(read_issue_data "$id" 2>/dev/null) || continue

            # Remove old edges where this issue is the source.
            # Target-side edges belong to their source issue and are handled
            # when that source is processed (avoids ordering issues).
            edge_data=$(echo "$edge_data" | grep -v "^${id} " || true)

            # Parse dep fields and add new edges
            for field in blocks depends_on parent_of relates_to; do
                local values
                values=$(echo "$data" | grep "^${field}:" | cut -d' ' -f2- | xargs)
                if [[ -n "$values" ]]; then
                    for target in $(echo "$values" | tr ',' '\n'); do
                        target=$(echo "$target" | xargs)
                        [[ -n "$target" ]] && edge_data="${edge_data}"$'\n'"${id} ${field} ${target}"
                    done
                fi
            done
        done

        # Update marker and write
        edge_data=$(echo "$edge_data" | grep -v "^last_rebuilt_from:" | grep -v "^$" || true)
        edge_data="last_rebuilt_from: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"$'\n'"${edge_data}"
        write_edge_index "$edge_data"
    fi
}

# ==========================================
# CYCLE DETECTION
# ==========================================

# Check if adding a blocks edge from->to would create a cycle
# Returns 1 if cycle detected, 0 otherwise
check_for_cycles() {
    local from="$1"
    local to="$2"

    # Get current blocking edges from index + proposed new edge
    local edges
    edges=$(read_edge_index | grep ' blocks ' | awk '{print $1, $3}')
    edges="${edges}"$'\n'"${from} ${to}"

    # tsort on macOS exits 0 even on cycles, so check stderr
    local tsort_stderr
    tsort_stderr=$(echo "$edges" | tsort 2>&1 >/dev/null)
    if echo "$tsort_stderr" | grep -q "cycle"; then
        return 1  # cycle detected
    fi
    return 0
}

# Append a value to a comma-separated header field (deduplicates)
# Usage: append_to_field <issue_id> <field_name> <value>
append_to_field() {
    local id="$1"
    local field="$2"
    local value="$3"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local data
    data=$(read_issue_data "$id") || {
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    }

    # Get current field value
    local current
    current=$(echo "$data" | grep "^${field}:" | cut -d' ' -f2- | xargs)

    # Check for duplicate
    if [[ -n "$current" ]]; then
        # Split on comma and check each entry
        local IFS=','
        for existing in $current; do
            existing=$(echo "$existing" | xargs)
            if [[ "$existing" == "$value" ]]; then
                echo -e "${YELLOW}Value '$value' already exists in $field for issue #$id${NC}" >&2
                return 0
            fi
        done
        unset IFS
        # Append with comma separator
        local new_value="${current},${value}"
    else
        local new_value="$value"
    fi

    # Use the same awk updater pattern as update_issue()
    local updated_data
    updated_data=$(echo "$data" | awk -v field="${field}:" -v value="$new_value" -v ts="$timestamp" '
        BEGIN { found=0; in_body=0 }
        /^---$/ { if (!found) { print field, value; found=1 }; in_body=1; print; next }
        in_body { print; next }
        $1 == field { print field, value; found=1; next }
        $1 == "updated:" { print "updated:", ts; next }
        { print }
    ')

    write_issue_data "$id" "$updated_data"
}

# Remove a value from a comma-separated header field
# Usage: remove_from_field <issue_id> <field_name> <value>
remove_from_field() {
    local id="$1"
    local field="$2"
    local value="$3"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local data
    data=$(read_issue_data "$id") || {
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    }

    # Get current field value
    local current
    current=$(echo "$data" | grep "^${field}:" | cut -d' ' -f2- | xargs)

    if [[ -z "$current" ]]; then
        return 0  # Nothing to remove
    fi

    # Filter out the value
    local new_value=""
    local IFS=','
    for existing in $current; do
        existing=$(echo "$existing" | xargs)
        if [[ "$existing" != "$value" ]]; then
            if [[ -n "$new_value" ]]; then
                new_value="${new_value},${existing}"
            else
                new_value="$existing"
            fi
        fi
    done
    unset IFS

    if [[ -z "$new_value" ]]; then
        # Field is now empty - remove it entirely
        local updated_data
        updated_data=$(echo "$data" | awk -v field="${field}:" -v ts="$timestamp" '
            $1 == field { next }
            $1 == "updated:" { print "updated:", ts; next }
            { print }
        ')
    else
        # Write back the filtered list
        local updated_data
        updated_data=$(echo "$data" | awk -v field="${field}:" -v value="$new_value" -v ts="$timestamp" '
            BEGIN { found=0; in_body=0 }
            /^---$/ { if (!found) { print field, value; found=1 }; in_body=1; print; next }
            in_body { print; next }
            $1 == field { print field, value; found=1; next }
            $1 == "updated:" { print "updated:", ts; next }
            { print }
        ')
    fi

    write_issue_data "$id" "$updated_data"
}

# Cascade unblock: when an issue is marked done, check all its dependents
# and unblock them if all their blockers are resolved.
# Usage: cascade_unblock <completed_id>
cascade_unblock() {
    local completed_id="$1"
    local edges
    edges=$(read_edge_index)

    # Find issues that have depends_on pointing to the completed issue
    # Use process substitution to avoid subshell variable issues
    while read -r dep_id _ blocker_id; do
        [[ -z "$dep_id" ]] && continue
        if [[ "$blocker_id" == "$completed_id" ]]; then
            # Check if all blockers for this dependent are done
            local dep_data
            dep_data=$(read_issue_data "$dep_id" 2>/dev/null) || continue
            local all_blockers
            all_blockers=$(echo "$dep_data" | grep "^depends_on:" | cut -d' ' -f2- | xargs)

            local all_resolved=true
            local IFS=','
            for blocker in $all_blockers; do
                [[ -z "$blocker" ]] && continue
                blocker=$(echo "$blocker" | xargs)
                local blocker_state
                blocker_state=$(read_issue_data "$blocker" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
                if [[ "$blocker_state" != "done" ]]; then
                    all_resolved=false
                    break
                fi
            done
            unset IFS

            if [[ "$all_resolved" == "true" ]]; then
                local current_state
                current_state=$(echo "$dep_data" | grep "^state:" | cut -d' ' -f2)
                if [[ "$current_state" == "blocked" ]]; then
                    update_issue "$dep_id" "state" "open"
                    echo -e "${GREEN}Unblocked issue #$dep_id${NC}"
                fi
            fi
        fi
    done < <(echo "$edges" | grep " depends_on ")
}

# Add a dependency relationship
# Usage: dep_add <from_id> <type> <to_id>
dep_add() {
    local from_id="$1"
    local dep_type="$2"
    local to_id="$3"

    # Validate arguments
    if [[ -z "$from_id" || -z "$dep_type" || -z "$to_id" ]]; then
        echo -e "${RED}Error: dep add requires <from_id> <type> <to_id>${NC}" >&2
        return 1
    fi

    # Reject self-dependency
    if [[ "$from_id" == "$to_id" ]]; then
        echo -e "${RED}Error: Cannot create self-dependency ($from_id -> $from_id)${NC}" >&2
        return 1
    fi

    # Validate type
    case "$dep_type" in
        blocks|depends_on|parent_of|relates_to) ;;
        *)
            echo -e "${RED}Error: Invalid dependency type '$dep_type'${NC}" >&2
            echo "Valid types: blocks, depends_on, parent_of, relates_to" >&2
            return 1
            ;;
    esac

    # Validate both issues exist
    if ! issue_exists "$from_id"; then
        echo -e "${RED}Error: Issue #$from_id not found${NC}" >&2
        return 1
    fi
    if ! issue_exists "$to_id"; then
        echo -e "${RED}Error: Issue #$to_id not found${NC}" >&2
        return 1
    fi

    # Cycle detection for blocking relationships
    case "$dep_type" in
        blocks)
            if ! check_for_cycles "$from_id" "$to_id"; then
                echo -e "${RED}Error: Adding '$from_id blocks $to_id' would create a cycle${NC}" >&2
                return 1
            fi
            ;;
        depends_on)
            # depends_on from->to is equivalent to to blocks from
            if ! check_for_cycles "$to_id" "$from_id"; then
                echo -e "${RED}Error: Adding '$from_id depends_on $to_id' would create a cycle${NC}" >&2
                return 1
            fi
            ;;
    esac

    # Write the dependency
    case "$dep_type" in
        blocks)
            # Bidirectional: from blocks to, to depends_on from
            append_to_field "$from_id" "blocks" "$to_id"
            append_to_field "$to_id" "depends_on" "$from_id"
            # Update edge index (both directions)
            add_edge "$from_id" "blocks" "$to_id"
            add_edge "$to_id" "depends_on" "$from_id"
            ;;
        depends_on)
            # Bidirectional: from depends_on to, to blocks from
            append_to_field "$from_id" "depends_on" "$to_id"
            append_to_field "$to_id" "blocks" "$from_id"
            # Update edge index (both directions)
            add_edge "$from_id" "depends_on" "$to_id"
            add_edge "$to_id" "blocks" "$from_id"
            ;;
        parent_of|relates_to)
            # Unidirectional: only write on from-issue
            append_to_field "$from_id" "$dep_type" "$to_id"
            # Update edge index
            add_edge "$from_id" "$dep_type" "$to_id"
            ;;
    esac

    # Auto-blocking: set the dependent issue to "blocked" if the blocker isn't done
    case "$dep_type" in
        blocks)
            # A blocks B => B should become blocked (unless B is already done)
            local target_state
            target_state=$(read_issue_data "$to_id" | grep "^state:" | cut -d' ' -f2)
            if [[ "$target_state" != "done" ]]; then
                update_issue "$to_id" "state" "blocked"
            fi
            ;;
        depends_on)
            # A depends_on B => A should become blocked (unless A is already done)
            local from_state
            from_state=$(read_issue_data "$from_id" | grep "^state:" | cut -d' ' -f2)
            if [[ "$from_state" != "done" ]]; then
                update_issue "$from_id" "state" "blocked"
            fi
            ;;
    esac

    echo -e "${GREEN}Added dependency: #$from_id $dep_type #$to_id${NC}"
}

# Remove a dependency relationship
# Usage: dep_rm <from_id> <type> <to_id>
dep_rm() {
    local from_id="$1"
    local dep_type="$2"
    local to_id="$3"

    # Validate arguments
    if [[ -z "$from_id" || -z "$dep_type" || -z "$to_id" ]]; then
        echo -e "${RED}Error: dep rm requires <from_id> <type> <to_id>${NC}" >&2
        return 1
    fi

    # Validate type
    case "$dep_type" in
        blocks|depends_on|parent_of|relates_to) ;;
        *)
            echo -e "${RED}Error: Invalid dependency type '$dep_type'${NC}" >&2
            return 1
            ;;
    esac

    # Validate both issues exist
    if ! issue_exists "$from_id"; then
        echo -e "${RED}Error: Issue #$from_id not found${NC}" >&2
        return 1
    fi
    if ! issue_exists "$to_id"; then
        echo -e "${RED}Error: Issue #$to_id not found${NC}" >&2
        return 1
    fi

    # Remove the dependency
    case "$dep_type" in
        blocks)
            # Bidirectional: remove from both sides
            remove_from_field "$from_id" "blocks" "$to_id"
            remove_from_field "$to_id" "depends_on" "$from_id"
            # Update edge index (both directions)
            remove_edge "$from_id" "blocks" "$to_id"
            remove_edge "$to_id" "depends_on" "$from_id"
            ;;
        depends_on)
            # Bidirectional: remove from both sides
            remove_from_field "$from_id" "depends_on" "$to_id"
            remove_from_field "$to_id" "blocks" "$from_id"
            # Update edge index (both directions)
            remove_edge "$from_id" "depends_on" "$to_id"
            remove_edge "$to_id" "blocks" "$from_id"
            ;;
        parent_of|relates_to)
            # Unidirectional: only remove from from-issue
            remove_from_field "$from_id" "$dep_type" "$to_id"
            # Update edge index
            remove_edge "$from_id" "$dep_type" "$to_id"
            ;;
    esac

    # After removing a blocking edge, check if the dependent should be unblocked
    local unblock_target=""
    case "$dep_type" in
        blocks) unblock_target="$to_id" ;;
        depends_on) unblock_target="$from_id" ;;
    esac

    if [[ -n "$unblock_target" ]]; then
        local remaining_blockers
        remaining_blockers=$(read_issue_data "$unblock_target" 2>/dev/null | grep "^depends_on:" | cut -d' ' -f2- | xargs)
        if [[ -z "$remaining_blockers" ]]; then
            local current_state
            current_state=$(read_issue_data "$unblock_target" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
            if [[ "$current_state" == "blocked" ]]; then
                update_issue "$unblock_target" "state" "open"
                echo -e "${GREEN}Unblocked issue #$unblock_target${NC}"
            fi
        else
            # There are remaining blockers -- check if all are done
            local all_resolved=true
            local IFS=','
            for blocker in $remaining_blockers; do
                [[ -z "$blocker" ]] && continue
                blocker=$(echo "$blocker" | xargs)
                local blocker_state
                blocker_state=$(read_issue_data "$blocker" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
                if [[ "$blocker_state" != "done" ]]; then
                    all_resolved=false
                    break
                fi
            done
            unset IFS
            if [[ "$all_resolved" == "true" ]]; then
                local current_state
                current_state=$(read_issue_data "$unblock_target" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
                if [[ "$current_state" == "blocked" ]]; then
                    update_issue "$unblock_target" "state" "open"
                    echo -e "${GREEN}Unblocked issue #$unblock_target${NC}"
                fi
            fi
        fi
    fi

    echo -e "${GREEN}Removed dependency: #$from_id $dep_type #$to_id${NC}"
}

# List dependency relationships
# Usage: dep_list [issue_id]
dep_list() {
    local target_id="$1"

    # Ensure edge index is current before querying
    ensure_edge_index_current

    if [[ -n "$target_id" ]]; then
        # Show deps for a specific issue
        if ! issue_exists "$target_id"; then
            echo -e "${RED}Error: Issue #$target_id not found${NC}" >&2
            return 1
        fi

        local data
        data=$(read_issue_data "$target_id")
        local front_matter
        front_matter=$(parse_front_matter "$data")

        local blocks=$(get_field_value "$front_matter" "blocks")
        local depends_on=$(get_field_value "$front_matter" "depends_on")
        local parent_of=$(get_field_value "$front_matter" "parent_of")
        local relates_to=$(get_field_value "$front_matter" "relates_to")

        echo -e "${BLUE}Dependencies for issue #$target_id:${NC}"
        [[ -n "$blocks" ]] && echo "  blocks: $blocks"
        [[ -n "$depends_on" ]] && echo "  depends_on: $depends_on"
        [[ -n "$parent_of" ]] && echo "  parent_of: $parent_of"
        [[ -n "$relates_to" ]] && echo "  relates_to: $relates_to"

        if [[ -z "$blocks" && -z "$depends_on" && -z "$parent_of" && -z "$relates_to" ]]; then
            echo "  (none)"
        fi
    else
        # Show all dependency relationships across all issues
        echo -e "${BLUE}All dependency relationships:${NC}"
        local found=false

        for ref in $(list_all_issues); do
            local id=$(extract_issue_id "$ref")
            local data
            data=$(read_issue_data "$id" 2>/dev/null) || continue
            local front_matter
            front_matter=$(parse_front_matter "$data")

            local blocks=$(get_field_value "$front_matter" "blocks")
            local depends_on=$(get_field_value "$front_matter" "depends_on")
            local parent_of=$(get_field_value "$front_matter" "parent_of")
            local relates_to=$(get_field_value "$front_matter" "relates_to")

            if [[ -n "$blocks" ]]; then
                local IFS=','
                for target in $blocks; do
                    target=$(echo "$target" | xargs)
                    echo "  #$id blocks #$target"
                    found=true
                done
                unset IFS
            fi
            if [[ -n "$depends_on" ]]; then
                local IFS=','
                for target in $depends_on; do
                    target=$(echo "$target" | xargs)
                    echo "  #$id depends_on #$target"
                    found=true
                done
                unset IFS
            fi
            if [[ -n "$parent_of" ]]; then
                local IFS=','
                for target in $parent_of; do
                    target=$(echo "$target" | xargs)
                    echo "  #$id parent_of #$target"
                    found=true
                done
                unset IFS
            fi
            if [[ -n "$relates_to" ]]; then
                local IFS=','
                for target in $relates_to; do
                    target=$(echo "$target" | xargs)
                    echo "  #$id relates_to #$target"
                    found=true
                done
                unset IFS
            fi
        done

        if [[ "$found" == "false" ]]; then
            echo "  (none)"
        fi
    fi
}

# Handle dep subcommand routing
# Usage: handle_dep <subcommand> [args...]
handle_dep() {
    local subcmd="$1"
    shift || true

    case "$subcmd" in
        add)
            dep_add "$@"
            ;;
        rm|remove)
            dep_rm "$@"
            ;;
        list|ls)
            dep_list "$@"
            ;;
        rebuild)
            rebuild_edge_index
            ;;
        *)
            echo -e "${RED}Error: Unknown dep subcommand '$subcmd'${NC}" >&2
            echo "Usage: git issue dep [add|rm|list|rebuild] [args...]" >&2
            echo "" >&2
            echo "Subcommands:" >&2
            echo "  add <from_id> <type> <to_id>   Add dependency" >&2
            echo "  rm  <from_id> <type> <to_id>   Remove dependency" >&2
            echo "  list [issue_id]                 List dependencies" >&2
            echo "  rebuild                         Rebuild dependency index" >&2
            echo "" >&2
            echo "Dependency types: blocks, depends_on, parent_of, relates_to" >&2
            return 1
            ;;
    esac
}

# ==========================================
# GRAPH QUERY FUNCTIONS
# ==========================================

# List issues ready to work on
# Ready = not done, not blocked, and all depends_on targets are done
list_ready_issues() {
    ensure_edge_index_current

    local results=""

    for ref in $(list_all_issues); do
        local id
        id=$(extract_issue_id "$ref")
        local data
        data=$(read_issue_data "$id" 2>/dev/null) || continue

        local state
        state=$(echo "$data" | grep "^state:" | cut -d' ' -f2)

        # Skip done and blocked issues
        [[ "$state" == "done" || "$state" == "blocked" ]] && continue

        # Check depends_on: all blockers must be done
        local depends_on
        depends_on=$(echo "$data" | grep "^depends_on:" | cut -d' ' -f2- | xargs)
        if [[ -n "$depends_on" ]]; then
            local all_done=true
            local IFS=','
            for blocker in $depends_on; do
                blocker=$(echo "$blocker" | xargs)
                [[ -z "$blocker" ]] && continue
                local blocker_state
                blocker_state=$(read_issue_data "$blocker" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
                if [[ "$blocker_state" != "done" ]]; then
                    all_done=false
                    break
                fi
            done
            unset IFS
            [[ "$all_done" == "false" ]] && continue
        fi

        local title
        title=$(echo "$data" | grep "^title:" | cut -d' ' -f2-)
        local priority
        priority=$(echo "$data" | grep "^priority:" | cut -d' ' -f2)
        local assignee
        assignee=$(echo "$data" | grep "^assignee:" | cut -d' ' -f2-)

        # Numeric rank for sorting (lower = higher priority)
        local rank
        case "$priority" in
            critical) rank=0 ;;
            high)     rank=1 ;;
            medium)   rank=2 ;;
            low)      rank=3 ;;
            *)        rank=9 ;;
        esac

        local line="#${id} [${state}]  ${title}  (P: ${priority})"
        [[ -n "$assignee" ]] && line="${line} -> ${assignee}"
        results="${results}${rank} ${line}"$'\n'
    done

    echo -e "${BLUE}Ready to work on:${NC}"
    if [[ -z "$results" ]]; then
        echo "  (none)"
    else
        echo "$results" | sort -n | sed 's/^[0-9] //' | while IFS= read -r line; do
            [[ -n "$line" ]] && echo "$line"
        done
    fi
}

# Topologically sort non-done issues using POSIX tsort
topo_sort_issues() {
    ensure_edge_index_current

    local edge_data
    edge_data=$(read_edge_index)

    # Collect all non-done issue IDs
    local non_done_ids=()
    for ref in $(list_all_issues); do
        local id
        id=$(extract_issue_id "$ref")
        local state
        state=$(read_issue_data "$id" 2>/dev/null | grep "^state:" | cut -d' ' -f2)
        [[ "$state" == "done" ]] && continue
        non_done_ids+=("$id")
    done

    if [[ ${#non_done_ids[@]} -eq 0 ]]; then
        echo "No non-done issues found."
        return 0
    fi

    # Build tsort input: blocks edges from edge index (only among non-done issues)
    local tsort_input=""
    local ids_in_edges=""

    while read -r from type to; do
        [[ -z "$from" || "$type" != "blocks" ]] && continue
        # Only include edges where both endpoints are non-done
        local from_ok=false to_ok=false
        for nid in "${non_done_ids[@]}"; do
            [[ "$nid" == "$from" ]] && from_ok=true
            [[ "$nid" == "$to" ]] && to_ok=true
        done
        if [[ "$from_ok" == "true" && "$to_ok" == "true" ]]; then
            tsort_input="${tsort_input}${from} ${to}"$'\n'
            ids_in_edges="${ids_in_edges}${from}"$'\n'"${to}"$'\n'
        fi
    done <<< "$edge_data"

    # Add self-pairs for standalone issues (not in any edge)
    for nid in "${non_done_ids[@]}"; do
        if ! echo "$ids_in_edges" | grep -qF "$nid"; then
            tsort_input="${tsort_input}${nid} ${nid}"$'\n'
        fi
    done

    # Run tsort
    local sorted
    sorted=$(echo "$tsort_input" | tsort 2>/dev/null) || {
        echo -e "${RED}Error: tsort failed (possible cycle in dependencies)${NC}" >&2
        return 1
    }

    echo -e "${BLUE}Topological order (do first ‚Üí do last):${NC}"
    local num=1
    echo "$sorted" | while IFS= read -r id; do
        [[ -z "$id" ]] && continue
        local data
        data=$(read_issue_data "$id" 2>/dev/null) || continue
        local title
        title=$(echo "$data" | grep "^title:" | cut -d' ' -f2-)
        local priority
        priority=$(echo "$data" | grep "^priority:" | cut -d' ' -f2)
        local depends_on
        depends_on=$(echo "$data" | grep "^depends_on:" | cut -d' ' -f2- | xargs)

        local line="${num}. #${id}  ${title}  (P: ${priority})"
        if [[ -n "$depends_on" ]]; then
            local blockers=""
            local IFS=','
            for b in $depends_on; do
                b=$(echo "$b" | xargs)
                [[ -n "$b" ]] && blockers="${blockers} #${b}"
            done
            unset IFS
            line="${line}  <- blocked by${blockers}"
        fi
        echo "$line"
        num=$((num + 1))
    done
}

# Show dependency edges in text mode
show_deps() {
    local target_id="$1"

    ensure_edge_index_current

    local edge_data
    edge_data=$(read_edge_index)

    # If a specific issue ID is given, do BFS to find reachable edges
    local edges_to_show=""
    if [[ -n "$target_id" ]]; then
        if ! issue_exists "$target_id"; then
            echo -e "${RED}Error: Issue #$target_id not found${NC}" >&2
            return 1
        fi

        # BFS from target_id through the edge index
        local visited=""
        local queue="$target_id"
        while [[ -n "$queue" ]]; do
            local current
            current=$(echo "$queue" | head -1)
            queue=$(echo "$queue" | tail -n +2)

            # Skip if already visited
            echo "$visited" | grep -qF "$current" && continue
            visited="${visited}${current}"$'\n'

            # Find all edges where current is the source (skip depends_on to avoid duplication)
            while read -r from type to; do
                [[ -z "$from" ]] && continue
                [[ "$type" == "depends_on" ]] && continue
                [[ "$from" == "$current" ]] && {
                    edges_to_show="${edges_to_show}${from} ${type} ${to}"$'\n'
                    # Add target to queue for BFS
                    if ! echo "$visited" | grep -qF "$to"; then
                        queue="${queue}${to}"$'\n'
                    fi
                }
            done <<< "$edge_data"
        done
    else
        # Show all edges, skip depends_on (inverse of blocks)
        while read -r from type to; do
            [[ -z "$from" ]] && continue
            [[ "$type" == "depends_on" ]] && continue
            [[ "$from" == "last_rebuilt_from:" ]] && continue
            edges_to_show="${edges_to_show}${from} ${type} ${to}"$'\n'
        done <<< "$edge_data"
    fi

    if [[ -z "$edges_to_show" ]]; then
        echo "No dependency edges found."
        return 0
    fi

    echo "$edges_to_show" | while read -r from type to; do
        [[ -z "$from" ]] && continue
        local from_title to_title
        from_title=$(read_issue_data "$from" 2>/dev/null | grep "^title:" | cut -d' ' -f2-)
        to_title=$(read_issue_data "$to" 2>/dev/null | grep "^title:" | cut -d' ' -f2-)
        echo "#${from} (${from_title}) -[${type}]-> #${to} (${to_title})"
    done
}

# Show dependency edges in Graphviz DOT format
show_deps_dot() {
    local target_id="$1"

    ensure_edge_index_current

    local edge_data
    edge_data=$(read_edge_index)

    # Collect edges (same BFS logic as show_deps)
    local edges_to_show=""
    if [[ -n "$target_id" ]]; then
        if ! issue_exists "$target_id"; then
            echo -e "${RED}Error: Issue #$target_id not found${NC}" >&2
            return 1
        fi

        local visited=""
        local queue="$target_id"
        while [[ -n "$queue" ]]; do
            local current
            current=$(echo "$queue" | head -1)
            queue=$(echo "$queue" | tail -n +2)

            echo "$visited" | grep -qF "$current" && continue
            visited="${visited}${current}"$'\n'

            while read -r from type to; do
                [[ -z "$from" ]] && continue
                [[ "$type" == "depends_on" ]] && continue
                [[ "$from" == "$current" ]] && {
                    edges_to_show="${edges_to_show}${from} ${type} ${to}"$'\n'
                    if ! echo "$visited" | grep -qF "$to"; then
                        queue="${queue}${to}"$'\n'
                    fi
                }
            done <<< "$edge_data"
        done
    else
        while read -r from type to; do
            [[ -z "$from" ]] && continue
            [[ "$type" == "depends_on" ]] && continue
            [[ "$from" == "last_rebuilt_from:" ]] && continue
            edges_to_show="${edges_to_show}${from} ${type} ${to}"$'\n'
        done <<< "$edge_data"
    fi

    # Collect unique node IDs
    local node_ids=""
    while read -r from type to; do
        [[ -z "$from" ]] && continue
        node_ids="${node_ids}${from}"$'\n'"${to}"$'\n'
    done <<< "$edges_to_show"
    node_ids=$(echo "$node_ids" | sort -u | grep -v '^$')

    echo "digraph deps {"
    echo "  rankdir=LR;"

    # Node definitions
    echo "$node_ids" | while IFS= read -r nid; do
        [[ -z "$nid" ]] && continue
        local title
        title=$(read_issue_data "$nid" 2>/dev/null | grep "^title:" | cut -d' ' -f2-)
        echo "  \"${nid}\" [label=\"${nid}\\n${title}\"];"
    done

    # Edge definitions
    echo "$edges_to_show" | while read -r from type to; do
        [[ -z "$from" ]] && continue
        local style=""
        [[ "$type" == "parent_of" || "$type" == "relates_to" ]] && style=", style=\"dashed\""
        echo "  \"${from}\" -> \"${to}\" [label=\"${type}\"${style}];"
    done

    echo "}"
}

# Handle deps command routing
handle_deps_command() {
    local target_id=""
    local dot_mode=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dot)
                dot_mode=true
                shift
                ;;
            *)
                target_id="$1"
                shift
                ;;
        esac
    done

    if [[ "$dot_mode" == "true" ]]; then
        show_deps_dot "$target_id"
    else
        show_deps "$target_id"
    fi
}

# Initialize storage backend before any operations
detect_storage_backend

# Main script logic
case "$1" in
    create)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'create' requires title${NC}"
            echo "Usage: git issue create 'Title' [--description='Description']"
            exit 1
        fi
        create_issue_with_flags "${@:2}"
        ;;
    add)
        # Legacy support - redirect to create
        echo -e "${YELLOW}Note: 'add' is deprecated, use 'create' for auto-generated hash IDs${NC}"
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'add' requires id and title${NC}"
            usage
            exit 1
        fi
        # Manual ID creation (legacy)
        manual_id="$2"
        manual_title="${@:3}"
        if issue_exists "$manual_id"; then
            echo -e "${RED}Issue #$manual_id already exists${NC}"
            exit 1
        fi
        # Create with manual ID
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        author=$(get_git_user)
        issue_data="id: $manual_id
title: $manual_title
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee:
hash_source: manual
---"
        write_issue_data "$manual_id" "$issue_data"
        echo -e "${GREEN}‚úì Created issue #$manual_id: $manual_title${NC}"
        ;;
    list)
        list_issues
        ;;
    show)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'show' requires issue id${NC}"
            usage
            exit 1
        fi
        
        issue_id="$2"
        show_commits=false
        
        # Check for --with-commits flag
        if [[ "$3" == "--with-commits" ]]; then
            show_commits=true
        fi
        
        # Show issue details
        show_issue "$issue_id"
        
        # Show related commits if requested
        if [[ "$show_commits" == true ]]; then
            echo ""
            echo -e "${BLUE}Related Commits:${NC}"
            related_commits=$(get_related_commits "$issue_id")
            
            if [[ -n "$related_commits" ]]; then
                echo "$related_commits" | while IFS= read -r commit_line; do
                    echo "  $commit_line"
                done
            else
                echo -e "  ${GRAY}No commits found with trailers referencing this issue${NC}"
                echo -e "  ${GRAY}Use 'git issue commit --fixes $issue_id' to link commits${NC}"
            fi
        fi
        ;;
    update)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'update' requires issue id and flags${NC}"
            echo "Usage: git issue update <id> --state=<state> [--priority=<priority>] [--assignee=<assignee>]"
            exit 1
        fi
        update_issue_with_flags "${@:2}"
        ;;
    comment)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'comment' requires id and text${NC}"
            usage
            exit 1
        fi
        add_comment "$2" "${@:3}"
        ;;
    link)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'link' requires id and commit${NC}"
            usage
            exit 1
        fi
        link_issue "$2" "$3"
        ;;
    commit)
        shift
        handle_commit_with_trailers "$@"
        ;;
    scan-commits)
        shift
        scan_commits_for_issues "$@"
        ;;
    setup-sync)
        setup_sync "$2"
        ;;
    import)
        shift
        import_issues "$@"
        ;;
    export)
        shift
        export_issues "$@"
        ;;
    dep)
        shift
        handle_dep "$@"
        ;;
    ready)
        list_ready_issues
        ;;
    topo)
        topo_sort_issues
        ;;
    deps)
        shift
        handle_deps_command "$@"
        ;;
    "--help"|"-h"|"help")
        usage
        ;;
    "")
        usage
        exit 1
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
        echo ""
        usage
        exit 1
        ;;
esac

# Clean up XDG environment if needed
cleanup_xdg_environment