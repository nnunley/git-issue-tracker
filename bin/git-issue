#!/bin/bash
# git-issue: Issue tracking using git notes (or XDG directories) and hash-based IDs
# Supports both git repositories and standalone XDG directory storage

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Issue states and priorities
STATES=("open" "in-progress" "review" "done" "blocked")
PRIORITIES=("low" "medium" "high" "critical")

# Storage backend detection  
STORAGE_TYPE=""
ISSUE_REPO_DIR=""

# OPTIMIZED: Cached variables for performance
CACHED_USER_NAME=""
ORIGINAL_GIT_DIR=""

# Detect storage backend (git or XDG bare repo)
detect_storage_backend() {
    # Only use git mode if we have a local .git directory
    if [[ -d ".git" ]] || [[ -f ".git" ]]; then
        STORAGE_TYPE="git"
        echo -e "${BLUE}Using current git repository${NC}" >&2
    else
        STORAGE_TYPE="xdg"
        # Use platform-appropriate data directory with bare git repo
        local data_home
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS: Use Application Support
            data_home="${XDG_DATA_HOME:-$HOME/Library/Application Support}"
        else
            # Linux/Unix: Use XDG Base Directory specification
            data_home="${XDG_DATA_HOME:-$HOME/.local/share}"
        fi
        local project_name=$(basename "$(pwd)")
        ISSUE_REPO_DIR="$data_home/git-issue/$project_name.git"
        
        # Initialize bare git repo if it doesn't exist
        if [[ ! -d "$ISSUE_REPO_DIR" ]]; then
            echo -e "${YELLOW}Creating bare git repository for issue tracking: $ISSUE_REPO_DIR${NC}" >&2
            mkdir -p "$ISSUE_REPO_DIR"
            git init --bare "$ISSUE_REPO_DIR" >/dev/null 2>&1
            
            # Set up git environment temporarily to create initial commit
            local temp_git_dir="$GIT_DIR"
            export GIT_DIR="$ISSUE_REPO_DIR"
            
            # Create initial commit for notes to attach to
            local empty_tree="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
            local commit=$(echo "Initial commit for issue tracking" | git commit-tree "$empty_tree")
            git update-ref HEAD "$commit"
            
            # Restore git environment
            if [[ -n "$temp_git_dir" ]]; then
                export GIT_DIR="$temp_git_dir"
            else
                unset GIT_DIR
            fi
        fi
        
        # Set up git environment for XDG repo
        ORIGINAL_GIT_DIR="$GIT_DIR"
        export GIT_DIR="$ISSUE_REPO_DIR"
        echo -e "${YELLOW}Using standalone git repository: $ISSUE_REPO_DIR${NC}" >&2
    fi
}

# Clean up XDG git environment
cleanup_xdg_environment() {
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        if [[ -n "$ORIGINAL_GIT_DIR" ]]; then
            export GIT_DIR="$ORIGINAL_GIT_DIR"
        else
            unset GIT_DIR
        fi
    fi
}

# OPTIMIZED: Cache git user name for performance
get_git_user() {
    if [[ -z "$CACHED_USER_NAME" ]]; then
        CACHED_USER_NAME=$(git config user.name 2>/dev/null || echo "Unknown")
    fi
    echo "$CACHED_USER_NAME"
}

# Get storage path for issue (now always git refs)
get_issue_storage_path() {
    local id="$1"
    echo "refs/notes/issue-$id"
}

# Function to display usage
usage() {
    echo "Usage: git issue [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  create <title> [--description=<desc>]  Create new issue (auto-generates hash ID)"
    echo "  list                                    List all issues"
    echo "  show <id>                               Show issue details"
    echo "  update <id> [--state=<state>] [--priority=<priority>] [--assignee=<assignee>] [--description=<desc>]  Update issue"
    echo "  comment <id> <text>                     Add comment to issue"
    echo "  link <id> <commit>                      Link issue to commit"
    echo "  import [--stdin|--file|--bulk] <files>  Import issues from various sources"
    echo "  export [--format=<fmt>] [<ids>]         Export issues (default: all)"
    echo "  setup-sync [enable|disable|status]     Configure automatic git notes sync"
    echo ""
    echo "Examples:"
    echo "  git issue create 'Add user authentication' --description='Implement OAuth2 login'"
    echo "  git issue update a1b2c3d --state=in-progress --priority=high"
    echo "  git issue update a1b2c3d --assignee='John Doe' --description='Updated requirements'"
    echo "  git issue comment a1b2c3d 'Started implementation'"
    echo "  gh issue list --json number,title,body,state,author,createdAt,updatedAt,url | gh-to-git-issue | git issue import"
    echo ""
    exit 1
}

# Get issue note ref (legacy - use get_issue_storage_path)
get_issue_ref() {
    echo "refs/notes/issue-$1"
}

# OPTIMIZED: Read issue data using git cat-file (plumbing)
read_issue_data() {
    local id="$1"
    local ref=$(get_issue_ref "$id")
    git cat-file -p "$ref" 2>/dev/null || return 1
}

# OPTIMIZED: Write issue data using git hash-object + update-ref (plumbing)
write_issue_data() {
    local id="$1"
    local data="$2"
    local ref=$(get_issue_ref "$id")
    
    # Use plumbing commands for direct object creation and ref update
    local object_hash=$(echo "$data" | git hash-object -w --stdin)
    git update-ref "$ref" "$object_hash"
}

# List all issues (always git refs now)
list_all_issues() {
    git for-each-ref --format="%(refname)" refs/notes/issue-* 2>/dev/null | sort
}

# Extract issue ID from storage reference (always git refs now)
extract_issue_id() {
    local ref="$1"
    echo "$ref" | sed 's/refs\/notes\/issue-//'
}

# Generate hash-based issue ID
generate_issue_id() {
    local title="$1"
    local author="$2"
    local timestamp="$3"
    
    # Create deterministic content for hashing
    local content="issue: $title
author: $author
created: $timestamp"
    
    # Generate git-style hash
    local hash=$(echo "$content" | git hash-object --stdin)
    
    # Use short version (7 characters, git default)
    echo "${hash:0:7}"
}

# Check if issue exists
issue_exists() {
    local id="$1"
    local ref=$(get_issue_ref "$id")
    git notes --ref="$ref" show >/dev/null 2>&1
}

# Parse front matter from issue data  
parse_front_matter() {
    local data="$1"
    echo "$data" | awk '/^---$/{p=1; next} /^---$/{p=0} !p && /^[a-z_]+:/ {print}'
}

# Parse comments from issue data
parse_comments() {
    local data="$1"
    echo "$data" | awk '/^---$/{p++; next} p>=2 {print}'
}

# Get field value from front matter
get_field_value() {
    local front_matter="$1"
    local field="$2"
    echo "$front_matter" | grep "^$field:" | cut -d' ' -f2- | xargs
}

# Create new issue with auto-generated hash ID
create_issue() {
    local title="$1"
    local description="$2"
    local author=$(get_git_user)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    # Generate hash ID
    local id=$(generate_issue_id "$title" "$author" "$timestamp")
    
    # Check for conflicts (rare but possible)
    local attempts=0
    while issue_exists "$id" && [[ $attempts -lt 100 ]]; do
        echo "⚠️  Hash collision detected for $id, regenerating..."
        # Add microsecond precision to avoid collision
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
        id=$(generate_issue_id "$title" "$author" "$timestamp")
        ((attempts++))
    done
    
    if [[ $attempts -ge 100 ]]; then
        echo -e "${RED}Unable to generate unique ID after 100 attempts${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Creating issue with hash ID: $id${NC}"
    
    # Create issue data (only include non-empty fields)
    local issue_data="id: $id
title: $title"
    [[ -n "$description" ]] && issue_data="$issue_data
description: $description"
    issue_data="$issue_data
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee: $author
hash_source: content
---"
    
    write_issue_data "$id" "$issue_data"
    
    echo -e "${GREEN}✓ Created issue #$id: $title${NC}"
    echo -e "${GRAY}   Use this ID for future operations: $id${NC}"
}

# List all issues
list_issues() {
    echo -e "${BLUE}Issues:${NC}"
    echo ""
    
    # Find all issue refs
    for ref in $(list_all_issues); do
        id=$(extract_issue_id "$ref")
        if data=$(read_issue_data "$id" 2>/dev/null); then
            # Extract key fields
            title=$(echo "$data" | grep "^title:" | cut -d' ' -f2-)
            state=$(echo "$data" | grep "^state:" | cut -d' ' -f2)
            priority=$(echo "$data" | grep "^priority:" | cut -d' ' -f2)
            assignee=$(echo "$data" | grep "^assignee:" | cut -d' ' -f2-)
            
            # Color based on state
            case "$state" in
                done) color=$GRAY ;;
                blocked) color=$RED ;;
                in-progress) color=$YELLOW ;;
                review) color=$BLUE ;;
                *) color=$NC ;;
            esac
            
            # Format output
            echo -ne "${color}#${id} [${state}] ${title} (P: ${priority})"
            [ -n "$assignee" ] && echo -n " → $assignee"
            echo -e "${NC}"
        fi
    done
}

# Show issue details
show_issue() {
    local id="$1"
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! issue_exists "$id"; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local data=$(read_issue_data "$id")
    local front_matter=$(parse_front_matter "$data")
    local comments=$(parse_comments "$data")
    
    # Extract fields
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local github_id=$(get_field_value "$front_matter" "github_id")
    local github_url=$(get_field_value "$front_matter" "github_url")
    local jira_id=$(get_field_value "$front_matter" "jira_id")
    local jira_url=$(get_field_value "$front_matter" "jira_url")
    local gitlab_id=$(get_field_value "$front_matter" "gitlab_id")
    local gitlab_url=$(get_field_value "$front_matter" "gitlab_url")
    local state=$(get_field_value "$front_matter" "state")
    local priority=$(get_field_value "$front_matter" "priority")
    local created=$(get_field_value "$front_matter" "created")
    local updated=$(get_field_value "$front_matter" "updated")
    local author=$(get_field_value "$front_matter" "author")
    local assignee=$(get_field_value "$front_matter" "assignee")
    
    # Display issue
    echo -e "${BOLD}Issue #$id${NC}"
    echo "============"
    echo "Title: $title"
    [[ -n "$description" ]] && echo "Description: $description"
    
    # Show external provider links
    [[ -n "$github_id" ]] && echo "GitHub: #$github_id ($github_url)"
    [[ -n "$jira_id" ]] && echo "Jira: $jira_id ($jira_url)"
    [[ -n "$gitlab_id" ]] && echo "GitLab: #$gitlab_id ($gitlab_url)"
    
    echo "State: $state"
    echo "Priority: $priority"
    echo "Author: $author"
    [[ -n "$assignee" ]] && echo "Assignee: $assignee"
    echo "Created: $created"
    echo "Updated: $updated"
    
    if [[ -n "$comments" ]]; then
        echo ""
        echo "Comments:"
        echo "---------"
        echo "$comments"
    fi
}

# Update issue field
update_issue() {
    local id=$1
    local field=$2
    local value="${@:3}"
    local ref=$(get_issue_ref "$id")
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate field
    case "$field" in
        state)
            if [[ ! " ${STATES[@]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid state: $value${NC}"
                echo "Valid states: ${STATES[*]}"
                return 1
            fi
            ;;
        priority)
            if [[ ! " ${PRIORITIES[@]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid priority: $value${NC}"
                echo "Valid priorities: ${PRIORITIES[*]}"
                return 1
            fi
            ;;
        assignee)
            # Accept any value for assignee
            ;;
        description)
            # Accept any value for description
            ;;
        *)
            echo -e "${RED}Invalid field: $field${NC}"
            echo "Valid fields: state, priority, assignee, description"
            return 1
            ;;
    esac
    
    # Get current data
    data=$(read_issue_data "$id")
    
    # Update the field
    updated_data=$(echo "$data" | awk -v field="$field:" -v value="$value" -v ts="$timestamp" '
        BEGIN { found=0; in_body=0 }
        /^---$/ { in_body=1; print; next }
        in_body { print; next }
        $1 == field { print field, value; found=1; next }
        $1 == "updated:" { print "updated:", ts; next }
        { print }
        END { if (!found && !in_body) print field, value }
    ')
    
    # Save updated data
    write_issue_data "$id" "$updated_data"
    echo -e "${GREEN}✓ Updated issue #$id: $field = $value${NC}"
}

# Update issue using git-style flags
update_issue_with_flags() {
    local id="$1"
    shift
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local state="" priority="" assignee="" description=""
    local has_updates=false
    
    # Parse git-style flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state=*)
                state="${1#*=}"
                has_updates=true
                ;;
            --priority=*)
                priority="${1#*=}"
                has_updates=true
                ;;
            --assignee=*)
                assignee="${1#*=}"
                has_updates=true
                ;;
            --description=*)
                description="${1#*=}"
                has_updates=true
                ;;
            --state|--priority|--assignee|--description)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: $1 requires a value${NC}" >&2
                    return 1
                fi
                case "$1" in
                    --state) state="$2"; has_updates=true ;;
                    --priority) priority="$2"; has_updates=true ;;
                    --assignee) assignee="$2"; has_updates=true ;;
                    --description) description="$2"; has_updates=true ;;
                esac
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --state, --priority, --assignee, --description" >&2
                return 1
                ;;
        esac
        shift
    done
    
    if [[ "$has_updates" == "false" ]]; then
        echo -e "${RED}Error: No update flags provided${NC}" >&2
        echo "Use --state, --priority, --assignee, or --description" >&2
        return 1
    fi
    
    # Validate values
    if [[ -n "$state" ]]; then
        case "$state" in
            "open"|"in-progress"|"review"|"done"|"blocked") ;;
            *) echo -e "${RED}Error: Invalid state '$state'${NC}" >&2
               echo "Valid states: open, in-progress, review, done, blocked" >&2
               return 1 ;;
        esac
    fi
    
    if [[ -n "$priority" ]]; then
        case "$priority" in
            "low"|"medium"|"high"|"critical") ;;
            *) echo -e "${RED}Error: Invalid priority '$priority'${NC}" >&2
               echo "Valid priorities: low, medium, high, critical" >&2
               return 1 ;;
        esac
    fi
    
    # Update using legacy function for each field
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local changes=""
    
    if [[ -n "$state" ]]; then
        update_issue "$id" "state" "$state"
        changes="state=$state "
    fi
    if [[ -n "$priority" ]]; then
        update_issue "$id" "priority" "$priority"
        changes="${changes}priority=$priority "
    fi
    if [[ -n "$assignee" ]]; then
        update_issue "$id" "assignee" "$assignee"
        changes="${changes}assignee=$assignee "
    fi
    if [[ -n "$description" ]]; then
        update_issue "$id" "description" "$description"
        changes="${changes}description=updated "
    fi
    
    echo -e "${GREEN}✓ Updated issue #$id: ${changes}${NC}"
}

# Create issue with git-style flags
create_issue_with_flags() {
    local title=""
    local description=""
    
    # Parse arguments for title and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --description=*)
                description="${1#*=}"
                ;;
            --description)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: --description requires a value${NC}" >&2
                    return 1
                fi
                description="$2"
                shift
                ;;
            --*)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --description" >&2
                return 1
                ;;
            *)
                if [[ -z "$title" ]]; then
                    title="$1"
                else
                    echo -e "${RED}Error: Multiple titles provided. Use quotes for titles with spaces.${NC}" >&2
                    return 1
                fi
                ;;
        esac
        shift
    done
    
    if [[ -z "$title" ]]; then
        echo -e "${RED}Error: Issue title is required${NC}" >&2
        echo "Usage: git issue create 'Title' [--description='Description']" >&2
        return 1
    fi
    
    create_issue "$title" "$description"
}

# Setup automatic git notes synchronization
setup_sync() {
    local action="${1:-enable}"
    
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        echo -e "${YELLOW}⚠️  Auto-sync is only available in git repositories, not XDG mode${NC}"
        return 1
    fi
    
    case "$action" in
        enable)
            setup_sync_enable
            ;;
        disable)
            setup_sync_disable
            ;;
        status)
            setup_sync_status
            ;;
        *)
            echo "Usage: git issue setup-sync [enable|disable|status]"
            echo ""
            echo "Commands:"
            echo "  enable   Install git hooks for automatic notes sync"
            echo "  disable  Remove git hooks and disable auto-sync"
            echo "  status   Show current sync configuration"
            return 1
            ;;
    esac
}

# Enable automatic sync
setup_sync_enable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    local script_dir="$(dirname "$(realpath "$0")")"
    
    echo -e "${BLUE}🔧 Setting up automatic git notes synchronization...${NC}"
    
    # Create hooks directory if it doesn't exist
    mkdir -p "$hooks_dir"
    
    # Install post-merge hook
    if [[ -f "$hooks_dir/post-merge" ]]; then
        echo -e "${YELLOW}⚠️  Existing post-merge hook found, backing up to post-merge.backup${NC}"
        mv "$hooks_dir/post-merge" "$hooks_dir/post-merge.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/post-merge" ]]; then
        cp "$script_dir/../hooks/post-merge" "$hooks_dir/post-merge"
        chmod +x "$hooks_dir/post-merge"
        echo -e "${GREEN}✓ Installed post-merge hook (auto-fetch notes)${NC}"
    else
        echo -e "${RED}❌ Could not find post-merge hook template${NC}"
        return 1
    fi
    
    # Install pre-push hook
    if [[ -f "$hooks_dir/pre-push" ]]; then
        echo -e "${YELLOW}⚠️  Existing pre-push hook found, backing up to pre-push.backup${NC}"
        mv "$hooks_dir/pre-push" "$hooks_dir/pre-push.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/pre-push" ]]; then
        cp "$script_dir/../hooks/pre-push" "$hooks_dir/pre-push"
        chmod +x "$hooks_dir/pre-push"
        echo -e "${GREEN}✓ Installed pre-push hook (auto-push notes)${NC}"
    else
        echo -e "${RED}❌ Could not find pre-push hook template${NC}"
        return 1
    fi
    
    # Enable sync in git config
    git config git-issue.sync.enabled true
    echo -e "${GREEN}✓ Enabled automatic notes sync in git config${NC}"
    
    # Configure automatic notes fetching
    git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*' 2>/dev/null || true
    echo -e "${GREEN}✓ Configured automatic notes fetching${NC}"
    
    echo ""
    echo -e "${GREEN}🎉 Automatic git notes sync is now enabled!${NC}"
    echo ""
    echo "Your issue notes will now:"
    echo "  • Auto-fetch when you pull/merge"
    echo "  • Auto-push when you push commits"
    echo ""
    echo "To disable: git issue setup-sync disable"
}

# Disable automatic sync
setup_sync_disable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}🔧 Disabling automatic git notes synchronization...${NC}"
    
    # Remove hooks (restore backups if they exist)
    if [[ -f "$hooks_dir/post-merge" ]]; then
        if [[ -f "$hooks_dir/post-merge.backup" ]]; then
            mv "$hooks_dir/post-merge.backup" "$hooks_dir/post-merge"
            echo -e "${GREEN}✓ Restored original post-merge hook${NC}"
        else
            rm "$hooks_dir/post-merge"
            echo -e "${GREEN}✓ Removed post-merge hook${NC}"
        fi
    fi
    
    if [[ -f "$hooks_dir/pre-push" ]]; then
        if [[ -f "$hooks_dir/pre-push.backup" ]]; then
            mv "$hooks_dir/pre-push.backup" "$hooks_dir/pre-push"
            echo -e "${GREEN}✓ Restored original pre-push hook${NC}"
        else
            rm "$hooks_dir/pre-push"
            echo -e "${GREEN}✓ Removed pre-push hook${NC}"
        fi
    fi
    
    # Disable sync in git config
    git config git-issue.sync.enabled false
    echo -e "${GREEN}✓ Disabled automatic notes sync in git config${NC}"
    
    echo ""
    echo -e "${GREEN}✓ Automatic git notes sync has been disabled${NC}"
    echo ""
    echo "You can manually sync notes with:"
    echo "  git fetch origin 'refs/notes/*:refs/notes/*'"
    echo "  git push origin 'refs/notes/issue-*'"
}

# Show sync status
setup_sync_status() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}Git Notes Sync Status${NC}"
    echo "===================="
    
    # Check configuration
    local sync_enabled=$(git config --get git-issue.sync.enabled 2>/dev/null || echo "false")
    echo "Config enabled: $sync_enabled"
    
    # Check hooks
    local post_merge_exists="❌"
    local pre_push_exists="❌"
    
    if [[ -f "$hooks_dir/post-merge" && -x "$hooks_dir/post-merge" ]]; then
        post_merge_exists="✅"
    fi
    
    if [[ -f "$hooks_dir/pre-push" && -x "$hooks_dir/pre-push" ]]; then
        pre_push_exists="✅"
    fi
    
    echo "Post-merge hook: $post_merge_exists"
    echo "Pre-push hook: $pre_push_exists"
    
    # Check notes refs configuration
    local notes_fetch_configured="❌"
    if git config --get-regexp "remote\..*\.fetch" | grep -q "refs/notes"; then
        notes_fetch_configured="✅"
    fi
    echo "Notes auto-fetch: $notes_fetch_configured"
    
    # Count existing notes
    local note_count=$(git for-each-ref --format="%(refname)" refs/notes/issue-* 2>/dev/null | wc -l)
    echo "Issue notes: $note_count"
    
    echo ""
    if [[ "$sync_enabled" == "true" && "$post_merge_exists" == "✅" && "$pre_push_exists" == "✅" ]]; then
        echo -e "${GREEN}✓ Automatic sync is fully configured and enabled${NC}"
    else
        echo -e "${YELLOW}⚠️  Automatic sync is not fully configured${NC}"
        echo "Run: git issue setup-sync enable"
    fi
}

# Import issues from various sources
import_issues() {
    local source="stdin"
    local format="auto"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --stdin)
                source="stdin"
                shift
                ;;
            --file)
                source="$2"
                shift 2
                ;;
            --bulk)
                source="bulk"
                shift
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                break
                ;;
        esac
    done
    
    case "$source" in
        stdin)
            import_from_stdin "$format"
            ;;
        bulk)
            import_bulk_files "$@"
            ;;
        *)
            import_from_file "$source" "$format"
            ;;
    esac
}

# Import from stdin
import_from_stdin() {
    local format="$1"
    local count=0
    
    echo -e "${BLUE}📥 Importing issues from stdin...${NC}" >&2
    
    # Read issue data blocks separated by blank lines
    local issue_data=""
    while IFS= read -r line; do
        if [[ -z "$line" && -n "$issue_data" ]]; then
            # Process complete issue
            if import_single_issue "$issue_data"; then
                ((count++))
            fi
            issue_data=""
        else
            issue_data="$issue_data$line"$'\n'
        fi
    done
    
    # Process final issue if exists
    if [[ -n "$issue_data" ]]; then
        if import_single_issue "$issue_data"; then
            ((count++))
        fi
    fi
    
    echo -e "${GREEN}✓ Imported $count issues${NC}" >&2
}

# Import from file
import_from_file() {
    local file="$1"
    local format="$2"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        return 1
    fi
    
    echo -e "${BLUE}📥 Importing issues from $file...${NC}" >&2
    cat "$file" | import_from_stdin "$format"
}

# Import bulk files
import_bulk_files() {
    local count=0
    local total=0
    
    echo -e "${BLUE}📥 Importing issues from multiple files...${NC}" >&2
    
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            echo -e "${YELLOW}Processing $file...${NC}" >&2
            ((total++))
            if import_from_file "$file" "auto" >&2; then
                ((count++))
            fi
        else
            echo -e "${RED}Warning: File not found: $file${NC}" >&2
        fi
    done
    
    echo -e "${GREEN}✓ Processed $count/$total files${NC}" >&2
}

# Import a single issue from data
import_single_issue() {
    local data="$1"
    
    # Extract ID and validate format
    local id=$(echo "$data" | grep "^id:" | cut -d' ' -f2- | xargs)
    if [[ -z "$id" ]]; then
        echo -e "${RED}Warning: Issue data missing ID, skipping${NC}" >&2
        return 1
    fi
    
    # Check if issue already exists
    if issue_exists "$id"; then
        echo -e "${YELLOW}Warning: Issue #$id already exists, skipping${NC}" >&2
        return 1
    fi
    
    # Write issue data
    if write_issue_data "$id" "$data"; then
        local title=$(echo "$data" | grep "^title:" | cut -d' ' -f2- | xargs)
        echo -e "${GREEN}✓ Imported issue #$id: $title${NC}" >&2
        return 0
    else
        echo -e "${RED}Failed to import issue #$id${NC}" >&2
        return 1
    fi
}

# Export issues to various formats
export_issues() {
    local format="git-issue"
    local output="stdout"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --github)
                format="github"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get issues to export (IDs or all)
    local issue_ids=("$@")
    if [[ ${#issue_ids[@]} -eq 0 ]]; then
        # Export all issues
        local refs=($(list_all_issues))
        for ref in "${refs[@]}"; do
            local id=$(get_issue_id_from_ref "$ref")
            issue_ids+=("$id")
        done
    fi
    
    echo -e "${BLUE}📤 Exporting ${#issue_ids[@]} issues...${NC}" >&2
    
    for id in "${issue_ids[@]}"; do
        if ! issue_exists "$id"; then
            echo -e "${RED}Warning: Issue #$id not found, skipping${NC}" >&2
            continue
        fi
        
        local data=$(read_issue_data "$id")
        
        case "$format" in
            github)
                export_to_github_format "$data"
                ;;
            git-issue|*)
                echo "$data"
                echo ""  # Separator between issues
                ;;
        esac
    done
}

# Export to GitHub-compatible format (for gh CLI)
export_to_github_format() {
    local data="$1"
    local front_matter=$(parse_front_matter "$data")
    
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local state=$(get_field_value "$front_matter" "state")
    local labels=$(get_field_value "$front_matter" "labels")
    
    # Map git-issue state to GitHub state
    local gh_state="open"
    case "$state" in
        done|closed) gh_state="closed" ;;
    esac
    
    # Output GitHub CLI compatible format
    cat << EOF
{
  "title": "$title",
  "body": "$description",
  "state": "$gh_state",
  "labels": [$(echo "$labels" | sed 's/,/", "/g' | sed 's/^/"/; s/$/"/' | sed 's/""//g')]
}
EOF
}

# Add comment to issue
add_comment() {
    local id=$1
    local comment="${@:2}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local author=$(get_git_user)
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Get current data and append comment
    data=$(read_issue_data "$id")
    updated_data="$data

[$timestamp] $author: $comment"
    
    write_issue_data "$id" "$updated_data"
    
    echo -e "${GREEN}✓ Added comment to issue #$id${NC}"
}

# Link issue to commit
link_issue() {
    local id=$1
    local commit=$2
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate commit
    if ! git rev-parse "$commit" >/dev/null 2>&1; then
        echo -e "${RED}Invalid commit: $commit${NC}"
        return 1
    fi
    
    commit_hash=$(git rev-parse --short "$commit")
    
    # Add link as comment
    add_comment "$id" "Linked to commit: $commit_hash"
    
    # Note functionality is integrated into git-issue
}

# Initialize storage backend before any operations
detect_storage_backend

# Main script logic
case "$1" in
    create)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'create' requires title${NC}"
            echo "Usage: git issue create 'Title' [--description='Description']"
            exit 1
        fi
        create_issue_with_flags "${@:2}"
        ;;
    add)
        # Legacy support - redirect to create
        echo -e "${YELLOW}Note: 'add' is deprecated, use 'create' for auto-generated hash IDs${NC}"
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'add' requires id and title${NC}"
            usage
        fi
        # Manual ID creation (legacy)
        manual_id="$2"
        manual_title="${@:3}"
        if issue_exists "$manual_id"; then
            echo -e "${RED}Issue #$manual_id already exists${NC}"
            exit 1
        fi
        # Create with manual ID
        ref=$(get_issue_ref "$manual_id")
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        author=$(get_git_user)
        cat <<EOF | git notes --ref="$ref" add -F -
id: $manual_id
title: $manual_title
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee: 
hash_source: manual
---
EOF
        echo -e "${GREEN}✓ Created issue #$manual_id: $manual_title${NC}"
        ;;
    list)
        list_issues
        ;;
    show)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'show' requires issue id${NC}"
            usage
        fi
        show_issue "$2"
        ;;
    update)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'update' requires issue id and flags${NC}"
            echo "Usage: git issue update <id> --state=<state> [--priority=<priority>] [--assignee=<assignee>]"
            exit 1
        fi
        update_issue_with_flags "${@:2}"
        ;;
    comment)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'comment' requires id and text${NC}"
            usage
        fi
        add_comment "$2" "${@:3}"
        ;;
    link)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'link' requires id and commit${NC}"
            usage
        fi
        link_issue "$2" "$3"
        ;;
    setup-sync)
        setup_sync "$2"
        ;;
    import)
        shift
        import_issues "$@"
        ;;
    export)
        shift  
        export_issues "$@"
        ;;
    "--help"|"-h"|"help")
        usage
        ;;
    "")
        usage
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
        echo ""
        usage
        exit 1
        ;;
esac

# Clean up XDG environment if needed
cleanup_xdg_environment