#!/bin/bash
# git-issue: Issue tracking using git notes (or XDG directories) and hash-based IDs
# Supports both git repositories and standalone XDG directory storage

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Issue states and priorities
STATES=("open" "in-progress" "review" "done" "blocked")
PRIORITIES=("low" "medium" "high" "critical")

# Storage backend detection  
STORAGE_TYPE=""
ISSUE_REPO_DIR=""

# OPTIMIZED: Cached variables for performance
CACHED_USER_NAME=""
ORIGINAL_GIT_DIR=""

# Detect storage backend (git or XDG bare repo)
detect_storage_backend() {
    # Only use git mode if we have a local .git directory
    if [[ -d ".git" ]] || [[ -f ".git" ]]; then
        STORAGE_TYPE="git"
        echo -e "${BLUE}Using current git repository${NC}" >&2
    else
        STORAGE_TYPE="xdg"
        # Use platform-appropriate data directory with bare git repo
        local data_home
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS: Use Application Support
            data_home="${XDG_DATA_HOME:-$HOME/Library/Application Support}"
        else
            # Linux/Unix: Use XDG Base Directory specification
            data_home="${XDG_DATA_HOME:-$HOME/.local/share}"
        fi
        local project_name=$(basename "$(pwd)")
        ISSUE_REPO_DIR="$data_home/git-issue/$project_name.git"
        
        # Initialize bare git repo if it doesn't exist
        if [[ ! -d "$ISSUE_REPO_DIR" ]]; then
            echo -e "${YELLOW}Creating bare git repository for issue tracking: $ISSUE_REPO_DIR${NC}" >&2
            mkdir -p "$ISSUE_REPO_DIR"
            git init --bare "$ISSUE_REPO_DIR" >/dev/null 2>&1
            
            # Set up git environment temporarily to create initial commit
            local temp_git_dir="$GIT_DIR"
            export GIT_DIR="$ISSUE_REPO_DIR"
            
            # Create initial commit for notes to attach to
            local empty_tree="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
            local commit=$(echo "Initial commit for issue tracking" | git commit-tree "$empty_tree")
            git update-ref HEAD "$commit"
            
            # Restore git environment
            if [[ -n "$temp_git_dir" ]]; then
                export GIT_DIR="$temp_git_dir"
            else
                unset GIT_DIR
            fi
        fi
        
        # Set up git environment for XDG repo
        ORIGINAL_GIT_DIR="$GIT_DIR"
        export GIT_DIR="$ISSUE_REPO_DIR"
        echo -e "${YELLOW}Using standalone git repository: $ISSUE_REPO_DIR${NC}" >&2
    fi
}

# Clean up XDG git environment
cleanup_xdg_environment() {
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        if [[ -n "$ORIGINAL_GIT_DIR" ]]; then
            export GIT_DIR="$ORIGINAL_GIT_DIR"
        else
            unset GIT_DIR
        fi
    fi
}

# OPTIMIZED: Cache git user name for performance
get_git_user() {
    if [[ -z "$CACHED_USER_NAME" ]]; then
        CACHED_USER_NAME=$(git config user.name 2>/dev/null || echo "Unknown")
    fi
    echo "$CACHED_USER_NAME"
}

# Get storage path for issue (now always git refs)
get_issue_storage_path() {
    local id="$1"
    echo "refs/notes/issue-$id"
}

# Function to display usage
usage() {
    echo "Usage: git issue [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  create <title> [--description=<desc>]  Create new issue (auto-generates hash ID)"
    echo "  list                                    List all issues"
    echo "  show <id> [--with-commits]              Show issue details (optionally with related commits)"
    echo "  update <id> [--state=<state>] [--priority=<priority>] [--assignee=<assignee>] [--description=<desc>]  Update issue"
    echo "  comment <id> <text>                     Add comment to issue"
    echo "  link <id> <commit>                      Link issue to commit (git notes)"
    echo "  commit [--issue|--fixes|--closes] <id>  Add git trailer to commit"
    echo "  scan-commits [--since=<date>]           Scan commit trailers for issue references"
    echo "  import [--stdin|--file|--bulk] <files>  Import issues from various sources"
    echo "  export [--format=<fmt>] [<ids>]         Export issues (default: all)"
    echo "  setup-sync [enable|disable|status]     Configure automatic git notes sync"
    echo ""
    echo "Examples:"
    echo "  git issue create 'Add user authentication' --description='Implement OAuth2 login'"
    echo "  git issue update a1b2c3d --state=in-progress --priority=high"
    echo "  git issue update a1b2c3d --assignee='John Doe' --description='Updated requirements'"
    echo "  git issue comment a1b2c3d 'Started implementation'"
    echo "  git issue commit --fixes a1b2c3d      # Add trailer to HEAD commit"
    echo "  git issue show a1b2c3d --with-commits # Show issue with related commits"
    echo "  git issue scan-commits --since='1 week ago'  # Find issue references in commits"
    echo "  gh issue list --json number,title,body,state,author,createdAt,updatedAt,url | gh-to-git-issue | git issue import"
    echo ""
    exit 1
}

# Get issue note ref (legacy - use get_issue_storage_path)
get_issue_ref() {
    echo "refs/notes/issue-$1"
}

# OPTIMIZED: Read issue data using git cat-file (plumbing)
read_issue_data() {
    local id="$1"
    local ref=$(get_issue_ref "$id")
    
    # Get the tree hash from the notes commit
    local tree_hash=$(git cat-file -p "$ref" 2>/dev/null | grep "^tree" | cut -d' ' -f2) || return 1
    
    # Get the blob hash from the tree (git notes store data in blobs)
    local blob_hash=$(git ls-tree "$tree_hash" 2>/dev/null | awk '{print $3}') || return 1
    
    # Read the actual issue content from the blob
    git cat-file -p "$blob_hash" 2>/dev/null || return 1
}

# OPTIMIZED: Write issue data using git hash-object + update-ref (plumbing)
write_issue_data() {
    local id="$1"
    local data="$2"
    local ref=$(get_issue_ref "$id")
    
    # Remove existing notes and add new data using git notes API
    git notes --ref="$ref" remove 2>/dev/null || true
    echo "$data" | git notes --ref="$ref" add -F -
}

# List all issues (always git refs now)
list_all_issues() {
    git for-each-ref --format="%(refname)" 'refs/notes/issue-*' 2>/dev/null | sort
}

# Extract issue ID from storage reference (always git refs now)
extract_issue_id() {
    local ref="$1"
    echo "$ref" | sed 's/refs\/notes\/issue-//'
}

# Generate hash-based issue ID
generate_issue_id() {
    local title="$1"
    local author="$2"
    local timestamp="$3"
    
    # Create deterministic content for hashing
    local content="issue: $title
author: $author
created: $timestamp"
    
    # Generate git-style hash
    local hash=$(echo "$content" | git hash-object --stdin)
    
    # Use short version (7 characters, git default)
    echo "${hash:0:7}"
}

# Check if issue exists
issue_exists() {
    local id="$1"
    local ref=$(get_issue_ref "$id")
    # Check if the git ref exists
    git show-ref --verify --quiet "$ref"
}

# Parse front matter from issue data  
parse_front_matter() {
    local data="$1"
    echo "$data" | awk '/^---$/{p=1; next} /^---$/{p=0} !p && /^[a-z_]+:/ {print}'
}

# Parse comments from issue data
parse_comments() {
    local data="$1"
    echo "$data" | awk '/^---$/{p++; next} p>=2 {print}'
}

# Get field value from front matter
get_field_value() {
    local front_matter="$1"
    local field="$2"
    echo "$front_matter" | grep "^$field:" | cut -d' ' -f2- | xargs
}

# Create new issue with auto-generated hash ID
create_issue() {
    local title="$1"
    local description="$2"
    local author=$(get_git_user)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    # Generate hash ID
    local id=$(generate_issue_id "$title" "$author" "$timestamp")
    
    # Check for conflicts (rare but possible)
    local attempts=0
    while issue_exists "$id" && [[ $attempts -lt 100 ]]; do
        echo "‚ö†Ô∏è  Hash collision detected for $id, regenerating..."
        # Add microsecond precision to avoid collision
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
        id=$(generate_issue_id "$title" "$author" "$timestamp")
        ((attempts++))
    done
    
    if [[ $attempts -ge 100 ]]; then
        echo -e "${RED}Unable to generate unique ID after 100 attempts${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Creating issue with hash ID: $id${NC}"
    
    # Create issue data (only include non-empty fields)
    local issue_data="id: $id
title: $title"
    [[ -n "$description" ]] && issue_data="$issue_data
description: $description"
    issue_data="$issue_data
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee: $author
hash_source: content
---"
    
    write_issue_data "$id" "$issue_data"
    
    echo -e "${GREEN}‚úì Created issue #$id: $title${NC}"
    echo -e "${GRAY}   Use this ID for future operations: $id${NC}"
}

# List all issues
list_issues() {
    echo -e "${BLUE}Issues:${NC}"
    echo ""
    
    # Find all issue refs
    for ref in $(list_all_issues); do
        id=$(extract_issue_id "$ref")
        if data=$(read_issue_data "$id" 2>/dev/null); then
            # Extract key fields
            title=$(echo "$data" | grep "^title:" | cut -d' ' -f2-)
            state=$(echo "$data" | grep "^state:" | cut -d' ' -f2)
            priority=$(echo "$data" | grep "^priority:" | cut -d' ' -f2)
            assignee=$(echo "$data" | grep "^assignee:" | cut -d' ' -f2-)
            
            # Color based on state
            case "$state" in
                done) color=$GRAY ;;
                blocked) color=$RED ;;
                in-progress) color=$YELLOW ;;
                review) color=$BLUE ;;
                *) color=$NC ;;
            esac
            
            # Format output
            echo -ne "${color}#${id} [${state}] ${title} (P: ${priority})"
            [ -n "$assignee" ] && echo -n " ‚Üí $assignee"
            echo -e "${NC}"
        fi
    done
}

# Show issue details
show_issue() {
    local id="$1"
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! issue_exists "$id"; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local data=$(read_issue_data "$id")
    local front_matter=$(parse_front_matter "$data")
    local comments=$(parse_comments "$data")
    
    # Extract fields
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local github_id=$(get_field_value "$front_matter" "github_id")
    local github_url=$(get_field_value "$front_matter" "github_url")
    local jira_id=$(get_field_value "$front_matter" "jira_id")
    local jira_url=$(get_field_value "$front_matter" "jira_url")
    local gitlab_id=$(get_field_value "$front_matter" "gitlab_id")
    local gitlab_url=$(get_field_value "$front_matter" "gitlab_url")
    local state=$(get_field_value "$front_matter" "state")
    local priority=$(get_field_value "$front_matter" "priority")
    local created=$(get_field_value "$front_matter" "created")
    local updated=$(get_field_value "$front_matter" "updated")
    local author=$(get_field_value "$front_matter" "author")
    local assignee=$(get_field_value "$front_matter" "assignee")
    local blocks=$(get_field_value "$front_matter" "blocks")
    local depends_on=$(get_field_value "$front_matter" "depends_on")
    local parent_of=$(get_field_value "$front_matter" "parent_of")
    local relates_to=$(get_field_value "$front_matter" "relates_to")

    # Display issue
    echo -e "${BOLD}Issue #$id${NC}"
    echo "============"
    echo "Title: $title"
    [[ -n "$description" ]] && echo "Description: $description"
    
    # Show external provider links
    [[ -n "$github_id" ]] && echo "GitHub: #$github_id ($github_url)"
    [[ -n "$jira_id" ]] && echo "Jira: $jira_id ($jira_url)"
    [[ -n "$gitlab_id" ]] && echo "GitLab: #$gitlab_id ($gitlab_url)"
    
    echo "State: $state"
    echo "Priority: $priority"
    echo "Author: $author"
    [[ -n "$assignee" ]] && echo "Assignee: $assignee"
    [[ -n "$blocks" ]] && echo "Blocks: $blocks"
    [[ -n "$depends_on" ]] && echo "Depends on: $depends_on"
    [[ -n "$parent_of" ]] && echo "Parent of: $parent_of"
    [[ -n "$relates_to" ]] && echo "Relates to: $relates_to"
    echo "Created: $created"
    echo "Updated: $updated"
    
    if [[ -n "$comments" ]]; then
        echo ""
        echo "Comments:"
        echo "---------"
        echo "$comments"
    fi
}

# Update issue field
update_issue() {
    local id=$1
    local field=$2
    local value="${@:3}"
    local ref=$(get_issue_ref "$id")
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate field
    case "$field" in
        state)
            if [[ ! " ${STATES[@]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid state: $value${NC}"
                echo "Valid states: ${STATES[*]}"
                return 1
            fi
            ;;
        priority)
            if [[ ! " ${PRIORITIES[@]} " =~ " ${value} " ]]; then
                echo -e "${RED}Invalid priority: $value${NC}"
                echo "Valid priorities: ${PRIORITIES[*]}"
                return 1
            fi
            ;;
        assignee)
            # Accept any value for assignee
            ;;
        description)
            # Accept any value for description
            ;;
        blocks|depends_on|parent_of|relates_to)
            # Accept comma-separated issue IDs
            ;;
        *)
            echo -e "${RED}Invalid field: $field${NC}"
            echo "Valid fields: state, priority, assignee, description, blocks, depends_on, parent_of, relates_to"
            return 1
            ;;
    esac
    
    # Get current data
    data=$(read_issue_data "$id")
    
    # Update the field
    updated_data=$(echo "$data" | awk -v field="$field:" -v value="$value" -v ts="$timestamp" '
        BEGIN { found=0; in_body=0 }
        /^---$/ { if (!found) { print field, value; found=1 }; in_body=1; print; next }
        in_body { print; next }
        $1 == field { print field, value; found=1; next }
        $1 == "updated:" { print "updated:", ts; next }
        { print }
    ')
    
    # Save updated data
    write_issue_data "$id" "$updated_data"
    echo -e "${GREEN}‚úì Updated issue #$id: $field = $value${NC}"
}

# Update issue using git-style flags
update_issue_with_flags() {
    local id="$1"
    shift
    
    if [[ -z "$id" ]]; then
        echo -e "${RED}Error: Issue ID is required${NC}" >&2
        return 1
    fi
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Error: Issue #$id not found${NC}" >&2
        return 1
    fi
    
    local state="" priority="" assignee="" description=""
    local blocks="" depends_on="" parent_of="" relates_to=""
    local has_updates=false
    
    # Parse git-style flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state=*)
                state="${1#*=}"
                has_updates=true
                ;;
            --priority=*)
                priority="${1#*=}"
                has_updates=true
                ;;
            --assignee=*)
                assignee="${1#*=}"
                has_updates=true
                ;;
            --description=*)
                description="${1#*=}"
                has_updates=true
                ;;
            --blocks=*)
                blocks="${1#*=}"
                has_updates=true
                ;;
            --depends-on=*)
                depends_on="${1#*=}"
                has_updates=true
                ;;
            --parent-of=*)
                parent_of="${1#*=}"
                has_updates=true
                ;;
            --relates-to=*)
                relates_to="${1#*=}"
                has_updates=true
                ;;
            --state|--priority|--assignee|--description|--blocks|--depends-on|--parent-of|--relates-to)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: $1 requires a value${NC}" >&2
                    return 1
                fi
                case "$1" in
                    --state) state="$2"; has_updates=true ;;
                    --priority) priority="$2"; has_updates=true ;;
                    --assignee) assignee="$2"; has_updates=true ;;
                    --description) description="$2"; has_updates=true ;;
                    --blocks) blocks="$2"; has_updates=true ;;
                    --depends-on) depends_on="$2"; has_updates=true ;;
                    --parent-of) parent_of="$2"; has_updates=true ;;
                    --relates-to) relates_to="$2"; has_updates=true ;;
                esac
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --state, --priority, --assignee, --description, --blocks, --depends-on, --parent-of, --relates-to" >&2
                return 1
                ;;
        esac
        shift
    done
    
    if [[ "$has_updates" == "false" ]]; then
        echo -e "${RED}Error: No update flags provided${NC}" >&2
        echo "Use --state, --priority, --assignee, --description, --blocks, --depends-on, --parent-of, or --relates-to" >&2
        return 1
    fi
    
    # Validate values
    if [[ -n "$state" ]]; then
        case "$state" in
            "open"|"in-progress"|"review"|"done"|"blocked") ;;
            *) echo -e "${RED}Error: Invalid state '$state'${NC}" >&2
               echo "Valid states: open, in-progress, review, done, blocked" >&2
               return 1 ;;
        esac
    fi
    
    if [[ -n "$priority" ]]; then
        case "$priority" in
            "low"|"medium"|"high"|"critical") ;;
            *) echo -e "${RED}Error: Invalid priority '$priority'${NC}" >&2
               echo "Valid priorities: low, medium, high, critical" >&2
               return 1 ;;
        esac
    fi
    
    # Update using legacy function for each field
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local changes=""
    
    if [[ -n "$state" ]]; then
        update_issue "$id" "state" "$state"
        changes="state=$state "
    fi
    if [[ -n "$priority" ]]; then
        update_issue "$id" "priority" "$priority"
        changes="${changes}priority=$priority "
    fi
    if [[ -n "$assignee" ]]; then
        update_issue "$id" "assignee" "$assignee"
        changes="${changes}assignee=$assignee "
    fi
    if [[ -n "$description" ]]; then
        update_issue "$id" "description" "$description"
        changes="${changes}description=updated "
    fi
    if [[ -n "$blocks" ]]; then
        update_issue "$id" "blocks" "$blocks"
        changes="${changes}blocks=$blocks "
    fi
    if [[ -n "$depends_on" ]]; then
        update_issue "$id" "depends_on" "$depends_on"
        changes="${changes}depends_on=$depends_on "
    fi
    if [[ -n "$parent_of" ]]; then
        update_issue "$id" "parent_of" "$parent_of"
        changes="${changes}parent_of=$parent_of "
    fi
    if [[ -n "$relates_to" ]]; then
        update_issue "$id" "relates_to" "$relates_to"
        changes="${changes}relates_to=$relates_to "
    fi

    echo -e "${GREEN}‚úì Updated issue #$id: ${changes}${NC}"
}

# Create issue with git-style flags
create_issue_with_flags() {
    local title=""
    local description=""
    
    # Parse arguments for title and flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --description=*)
                description="${1#*=}"
                ;;
            --description)
                if [[ $# -lt 2 ]]; then
                    echo -e "${RED}Error: --description requires a value${NC}" >&2
                    return 1
                fi
                description="$2"
                shift
                ;;
            --*)
                echo -e "${RED}Error: Unknown flag '$1'${NC}" >&2
                echo "Valid flags: --description" >&2
                return 1
                ;;
            *)
                if [[ -z "$title" ]]; then
                    title="$1"
                else
                    echo -e "${RED}Error: Multiple titles provided. Use quotes for titles with spaces.${NC}" >&2
                    return 1
                fi
                ;;
        esac
        shift
    done
    
    if [[ -z "$title" ]]; then
        echo -e "${RED}Error: Issue title is required${NC}" >&2
        echo "Usage: git issue create 'Title' [--description='Description']" >&2
        return 1
    fi
    
    create_issue "$title" "$description"
}

# Setup automatic git notes synchronization
setup_sync() {
    local action="${1:-enable}"
    
    if [[ "$STORAGE_TYPE" == "xdg" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Auto-sync is only available in git repositories, not XDG mode${NC}"
        return 1
    fi
    
    case "$action" in
        enable)
            setup_sync_enable
            ;;
        disable)
            setup_sync_disable
            ;;
        status)
            setup_sync_status
            ;;
        *)
            echo "Usage: git issue setup-sync [enable|disable|status]"
            echo ""
            echo "Commands:"
            echo "  enable   Install git hooks for automatic notes sync"
            echo "  disable  Remove git hooks and disable auto-sync"
            echo "  status   Show current sync configuration"
            return 1
            ;;
    esac
}

# Enable automatic sync
setup_sync_enable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    local script_dir="$(dirname "$(realpath "$0")")"
    
    echo -e "${BLUE}üîß Setting up automatic git notes synchronization...${NC}"
    
    # Create hooks directory if it doesn't exist
    mkdir -p "$hooks_dir"
    
    # Install post-merge hook
    if [[ -f "$hooks_dir/post-merge" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Existing post-merge hook found, backing up to post-merge.backup${NC}"
        mv "$hooks_dir/post-merge" "$hooks_dir/post-merge.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/post-merge" ]]; then
        cp "$script_dir/../hooks/post-merge" "$hooks_dir/post-merge"
        chmod +x "$hooks_dir/post-merge"
        echo -e "${GREEN}‚úì Installed post-merge hook (auto-fetch notes)${NC}"
    else
        echo -e "${RED}‚ùå Could not find post-merge hook template${NC}"
        return 1
    fi
    
    # Install pre-push hook
    if [[ -f "$hooks_dir/pre-push" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Existing pre-push hook found, backing up to pre-push.backup${NC}"
        mv "$hooks_dir/pre-push" "$hooks_dir/pre-push.backup"
    fi
    
    if [[ -f "$script_dir/../hooks/pre-push" ]]; then
        cp "$script_dir/../hooks/pre-push" "$hooks_dir/pre-push"
        chmod +x "$hooks_dir/pre-push"
        echo -e "${GREEN}‚úì Installed pre-push hook (auto-push notes)${NC}"
    else
        echo -e "${RED}‚ùå Could not find pre-push hook template${NC}"
        return 1
    fi
    
    # Enable sync in git config
    git config git-issue.sync.enabled true
    echo -e "${GREEN}‚úì Enabled automatic notes sync in git config${NC}"
    
    # Configure automatic notes fetching
    git config --add remote.origin.fetch '+refs/notes/*:refs/notes/*' 2>/dev/null || true
    echo -e "${GREEN}‚úì Configured automatic notes fetching${NC}"
    
    echo ""
    echo -e "${GREEN}üéâ Automatic git notes sync is now enabled!${NC}"
    echo ""
    echo "Your issue notes will now:"
    echo "  ‚Ä¢ Auto-fetch when you pull/merge"
    echo "  ‚Ä¢ Auto-push when you push commits"
    echo ""
    echo "To disable: git issue setup-sync disable"
}

# Disable automatic sync
setup_sync_disable() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}üîß Disabling automatic git notes synchronization...${NC}"
    
    # Remove hooks (restore backups if they exist)
    if [[ -f "$hooks_dir/post-merge" ]]; then
        if [[ -f "$hooks_dir/post-merge.backup" ]]; then
            mv "$hooks_dir/post-merge.backup" "$hooks_dir/post-merge"
            echo -e "${GREEN}‚úì Restored original post-merge hook${NC}"
        else
            rm "$hooks_dir/post-merge"
            echo -e "${GREEN}‚úì Removed post-merge hook${NC}"
        fi
    fi
    
    if [[ -f "$hooks_dir/pre-push" ]]; then
        if [[ -f "$hooks_dir/pre-push.backup" ]]; then
            mv "$hooks_dir/pre-push.backup" "$hooks_dir/pre-push"
            echo -e "${GREEN}‚úì Restored original pre-push hook${NC}"
        else
            rm "$hooks_dir/pre-push"
            echo -e "${GREEN}‚úì Removed pre-push hook${NC}"
        fi
    fi
    
    # Disable sync in git config
    git config git-issue.sync.enabled false
    echo -e "${GREEN}‚úì Disabled automatic notes sync in git config${NC}"
    
    echo ""
    echo -e "${GREEN}‚úì Automatic git notes sync has been disabled${NC}"
    echo ""
    echo "You can manually sync notes with:"
    echo "  git fetch origin 'refs/notes/*:refs/notes/*'"
    echo "  git push origin 'refs/notes/issue-*'"
}

# Show sync status
setup_sync_status() {
    local git_dir=$(git rev-parse --git-dir)
    local hooks_dir="$git_dir/hooks"
    
    echo -e "${BLUE}Git Notes Sync Status${NC}"
    echo "===================="
    
    # Check configuration
    local sync_enabled=$(git config --get git-issue.sync.enabled 2>/dev/null || echo "false")
    echo "Config enabled: $sync_enabled"
    
    # Check hooks
    local post_merge_exists="‚ùå"
    local pre_push_exists="‚ùå"
    
    if [[ -f "$hooks_dir/post-merge" && -x "$hooks_dir/post-merge" ]]; then
        post_merge_exists="‚úÖ"
    fi
    
    if [[ -f "$hooks_dir/pre-push" && -x "$hooks_dir/pre-push" ]]; then
        pre_push_exists="‚úÖ"
    fi
    
    echo "Post-merge hook: $post_merge_exists"
    echo "Pre-push hook: $pre_push_exists"
    
    # Check notes refs configuration
    local notes_fetch_configured="‚ùå"
    if git config --get-regexp "remote\..*\.fetch" | grep -q "refs/notes"; then
        notes_fetch_configured="‚úÖ"
    fi
    echo "Notes auto-fetch: $notes_fetch_configured"
    
    # Count existing notes
    local note_count=$(git for-each-ref --format="%(refname)" refs/notes/issue-* 2>/dev/null | wc -l)
    echo "Issue notes: $note_count"
    
    echo ""
    if [[ "$sync_enabled" == "true" && "$post_merge_exists" == "‚úÖ" && "$pre_push_exists" == "‚úÖ" ]]; then
        echo -e "${GREEN}‚úì Automatic sync is fully configured and enabled${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Automatic sync is not fully configured${NC}"
        echo "Run: git issue setup-sync enable"
    fi
}

# Import issues from various sources
import_issues() {
    local source="stdin"
    local format="auto"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --stdin)
                source="stdin"
                shift
                ;;
            --file)
                source="$2"
                shift 2
                ;;
            --bulk)
                source="bulk"
                shift
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                break
                ;;
        esac
    done
    
    case "$source" in
        stdin)
            import_from_stdin "$format"
            ;;
        bulk)
            import_bulk_files "$@"
            ;;
        *)
            import_from_file "$source" "$format"
            ;;
    esac
}

# Import from stdin
import_from_stdin() {
    local format="$1"
    local count=0
    
    echo -e "${BLUE}üì• Importing issues from stdin...${NC}" >&2
    
    # Read issue data blocks separated by blank lines
    local issue_data=""
    while IFS= read -r line; do
        if [[ -z "$line" && -n "$issue_data" ]]; then
            # Process complete issue
            if import_single_issue "$issue_data"; then
                ((count++))
            fi
            issue_data=""
        else
            issue_data="$issue_data$line"$'\n'
        fi
    done
    
    # Process final issue if exists
    if [[ -n "$issue_data" ]]; then
        if import_single_issue "$issue_data"; then
            ((count++))
        fi
    fi
    
    echo -e "${GREEN}‚úì Imported $count issues${NC}" >&2
}

# Import from file
import_from_file() {
    local file="$1"
    local format="$2"
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        return 1
    fi
    
    echo -e "${BLUE}üì• Importing issues from $file...${NC}" >&2
    cat "$file" | import_from_stdin "$format"
}

# Import bulk files
import_bulk_files() {
    local count=0
    local total=0
    
    echo -e "${BLUE}üì• Importing issues from multiple files...${NC}" >&2
    
    for file in "$@"; do
        if [[ -f "$file" ]]; then
            echo -e "${YELLOW}Processing $file...${NC}" >&2
            ((total++))
            if import_from_file "$file" "auto" >&2; then
                ((count++))
            fi
        else
            echo -e "${RED}Warning: File not found: $file${NC}" >&2
        fi
    done
    
    echo -e "${GREEN}‚úì Processed $count/$total files${NC}" >&2
}

# Import a single issue from data
import_single_issue() {
    local data="$1"
    
    # Extract ID and validate format
    local id=$(echo "$data" | grep "^id:" | cut -d' ' -f2- | xargs)
    if [[ -z "$id" ]]; then
        echo -e "${RED}Warning: Issue data missing ID, skipping${NC}" >&2
        return 1
    fi
    
    # Check if issue already exists
    if issue_exists "$id"; then
        echo -e "${YELLOW}Warning: Issue #$id already exists, skipping${NC}" >&2
        return 1
    fi
    
    # Write issue data
    if write_issue_data "$id" "$data"; then
        local title=$(echo "$data" | grep "^title:" | cut -d' ' -f2- | xargs)
        echo -e "${GREEN}‚úì Imported issue #$id: $title${NC}" >&2
        return 0
    else
        echo -e "${RED}Failed to import issue #$id${NC}" >&2
        return 1
    fi
}

# Export issues to various formats
export_issues() {
    local format="git-issue"
    local output="stdout"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --github)
                format="github"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get issues to export (IDs or all)
    local issue_ids=("$@")
    if [[ ${#issue_ids[@]} -eq 0 ]]; then
        # Export all issues
        local refs=($(list_all_issues))
        for ref in "${refs[@]}"; do
            local id=$(get_issue_id_from_ref "$ref")
            issue_ids+=("$id")
        done
    fi
    
    echo -e "${BLUE}üì§ Exporting ${#issue_ids[@]} issues...${NC}" >&2
    
    for id in "${issue_ids[@]}"; do
        if ! issue_exists "$id"; then
            echo -e "${RED}Warning: Issue #$id not found, skipping${NC}" >&2
            continue
        fi
        
        local data=$(read_issue_data "$id")
        
        case "$format" in
            github)
                export_to_github_format "$data"
                ;;
            git-issue|*)
                echo "$data"
                echo ""  # Separator between issues
                ;;
        esac
    done
}

# Export to GitHub-compatible format (for gh CLI)
export_to_github_format() {
    local data="$1"
    local front_matter=$(parse_front_matter "$data")
    
    local title=$(get_field_value "$front_matter" "title")
    local description=$(get_field_value "$front_matter" "description")
    local state=$(get_field_value "$front_matter" "state")
    local labels=$(get_field_value "$front_matter" "labels")
    
    # Map git-issue state to GitHub state
    local gh_state="open"
    case "$state" in
        done|closed) gh_state="closed" ;;
    esac
    
    # Output GitHub CLI compatible format
    cat << EOF
{
  "title": "$title",
  "body": "$description",
  "state": "$gh_state",
  "labels": [$(echo "$labels" | sed 's/,/", "/g' | sed 's/^/"/; s/$/"/' | sed 's/""//g')]
}
EOF
}

# Add comment to issue
add_comment() {
    local id=$1
    local comment="${@:2}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local author=$(get_git_user)
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Get current data and append comment
    data=$(read_issue_data "$id")
    updated_data="$data

[$timestamp] $author: $comment"
    
    write_issue_data "$id" "$updated_data"
    
    echo -e "${GREEN}‚úì Added comment to issue #$id${NC}"
}

# Link issue to commit
link_issue() {
    local id=$1
    local commit=$2
    
    if ! read_issue_data "$id" >/dev/null 2>&1; then
        echo -e "${RED}Issue #$id not found${NC}"
        return 1
    fi
    
    # Validate commit
    if ! git rev-parse "$commit" >/dev/null 2>&1; then
        echo -e "${RED}Invalid commit: $commit${NC}"
        return 1
    fi
    
    commit_hash=$(git rev-parse --short "$commit")
    
    # Add link as comment
    add_comment "$id" "Linked to commit: $commit_hash"
    
    # Note functionality is integrated into git-issue
}

# ==========================================
# GIT TRAILERS INTEGRATION FUNCTIONS
# ==========================================

# Parse issue trailers from commit message
parse_issue_trailers() {
    local commit="$1"
    if [[ -z "$commit" ]]; then
        echo -e "${RED}Error: Commit hash required${NC}" >&2
        return 1
    fi
    
    # Get commit message and parse trailers
    git show --format="%B" -s "$commit" 2>/dev/null | \
        git interpret-trailers --parse 2>/dev/null | \
        grep -E "^(Issue|Fixes|Closes|Related-To):" || true
}

# Add trailer to commit message (creates new commit with trailer)
add_issue_trailer() {
    local commit="$1"
    local trailer_type="$2"  # issue, fixes, closes, related-to
    local issue_id="$3"
    
    if [[ -z "$commit" || -z "$trailer_type" || -z "$issue_id" ]]; then
        echo -e "${RED}Error: add_issue_trailer requires commit, trailer_type, and issue_id${NC}" >&2
        return 1
    fi
    
    # Validate commit exists
    if ! git rev-parse "$commit" >/dev/null 2>&1; then
        echo -e "${RED}Error: Invalid commit: $commit${NC}" >&2
        return 1
    fi
    
    # Format trailer key
    local trailer_key
    case "$trailer_type" in
        issue) trailer_key="Issue" ;;
        fixes) trailer_key="Fixes" ;;
        closes) trailer_key="Closes" ;;
        related-to) trailer_key="Related-To" ;;
        *) 
            echo -e "${RED}Error: Invalid trailer type: $trailer_type${NC}" >&2
            echo "Valid types: issue, fixes, closes, related-to" >&2
            return 1
            ;;
    esac
    
    # Get current commit message
    local commit_msg
    commit_msg=$(git show --format="%B" -s "$commit")
    
    # Add trailer to message
    local new_msg
    new_msg=$(echo "$commit_msg" | git interpret-trailers --trailer "${trailer_key}: #${issue_id}")
    
    echo -e "${GREEN}Trailer added: ${trailer_key}: #${issue_id}${NC}"
    echo -e "${YELLOW}Note: This would modify commit $commit${NC}"
    echo -e "${YELLOW}Use git commit --amend to apply changes interactively${NC}"
}

# Scan commit history for issue references
scan_commits_for_issues() {
    local since="${1:-}"
    local format="${2:-summary}"
    
    echo -e "${BLUE}üîç Scanning commits for issue references...${NC}"
    echo ""
    
    # Build git log arguments
    local git_log_args=("--oneline")
    if [[ -n "$since" ]]; then
        git_log_args+=("--since=$since")
    fi
    
    # Get commit hashes
    local commit_count=0
    local issue_refs_found=0
    
    git log "${git_log_args[@]}" --format="%H %s" | while IFS=' ' read -r commit_hash commit_subject; do
        commit_count=$((commit_count + 1))
        
        # Parse trailers from this commit
        local trailers
        trailers=$(parse_issue_trailers "$commit_hash")
        
        if [[ -n "$trailers" ]]; then
            issue_refs_found=$((issue_refs_found + 1))
            
            if [[ "$format" == "detailed" ]]; then
                echo -e "${GREEN}Commit: ${commit_hash:0:7}${NC} - $commit_subject"
                echo "$trailers" | while IFS= read -r trailer; do
                    echo "  $trailer"
                done
                echo ""
            else
                # Summary format
                echo "$trailers" | while IFS= read -r trailer; do
                    local issue_id=$(echo "$trailer" | grep -o '#[a-f0-9]\{7\}' | sed 's/#//')
                    local trailer_type=$(echo "$trailer" | cut -d':' -f1)
                    echo "${commit_hash:0:7} $trailer_type: #$issue_id"
                done
            fi
        fi
    done
    
    if [[ $issue_refs_found -eq 0 ]]; then
        echo -e "${YELLOW}No issue references found in commit trailers${NC}"
        echo -e "${GRAY}Tip: Use 'git issue commit --fixes <id>' to add trailers to commits${NC}"
    fi
}

# Get commits related to an issue (by scanning trailers)
get_related_commits() {
    local issue_id="$1"
    
    if [[ -z "$issue_id" ]]; then
        echo -e "${RED}Error: Issue ID required${NC}" >&2
        return 1
    fi
    
    # Scan all commits for references to this issue
    git log --oneline --format="%H" | while read -r commit_hash; do
        local trailers
        trailers=$(parse_issue_trailers "$commit_hash" 2>/dev/null || true)
        
        if echo "$trailers" | grep -q "#$issue_id"; then
            # Found a reference to this issue
            local commit_subject
            commit_subject=$(git show --format="%s" -s "$commit_hash")
            local trailer_types
            trailer_types=$(echo "$trailers" | grep "#$issue_id" | cut -d':' -f1 | tr '\n' ',' | sed 's/,$//')
            
            echo "${commit_hash:0:7} [$trailer_types] $commit_subject"
        fi
    done
}

# Handle git issue commit command with trailers
handle_commit_with_trailers() {
    local issue_id=""
    local trailer_type="issue"
    local commit="HEAD"
    local show_help=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --issue)
                trailer_type="issue"
                issue_id="$2"
                shift 2
                ;;
            --fixes)
                trailer_type="fixes" 
                issue_id="$2"
                shift 2
                ;;
            --closes)
                trailer_type="closes"
                issue_id="$2"
                shift 2
                ;;
            --related-to)
                trailer_type="related-to"
                issue_id="$2"
                shift 2
                ;;
            --commit)
                commit="$2"
                shift 2
                ;;
            --help|-h)
                show_help=true
                shift
                ;;
            *)
                echo -e "${RED}Error: Unknown option '$1'${NC}" >&2
                show_help=true
                break
                ;;
        esac
    done
    
    if [[ "$show_help" == true ]] || [[ -z "$issue_id" ]]; then
        echo "Usage: git issue commit [OPTIONS]"
        echo ""
        echo "Add issue trailers to git commits for standardized issue tracking"
        echo ""
        echo "Options:"
        echo "  --issue <id>      Link commit to issue (default)"
        echo "  --fixes <id>      Mark issue as fixed by this commit"
        echo "  --closes <id>     Mark issue as closed by this commit" 
        echo "  --related-to <id> Reference related issue"
        echo "  --commit <hash>   Target commit (default: HEAD)"
        echo "  --help, -h        Show this help"
        echo ""
        echo "Examples:"
        echo "  git issue commit --fixes a1b2c3d"
        echo "  git issue commit --issue b2c3d4e --commit abc1234"
        echo "  git issue commit --closes c3d4e5f"
        return 1
    fi
    
    # Validate issue exists
    if ! issue_exists "$issue_id"; then
        echo -e "${RED}Error: Issue #$issue_id not found${NC}" >&2
        return 1
    fi
    
    # Add trailer
    add_issue_trailer "$commit" "$trailer_type" "$issue_id"
    
    # If this is a fixes/closes trailer, update the issue state
    if [[ "$trailer_type" == "fixes" || "$trailer_type" == "closes" ]]; then
        echo ""
        echo -e "${YELLOW}Updating issue state...${NC}"
        update_issue "$issue_id" state done
        
        # Add comment about the commit
        local commit_short=$(git rev-parse --short "$commit")
        local commit_subject=$(git show --format="%s" -s "$commit")
        add_comment "$issue_id" "Resolved by commit $commit_short: $commit_subject"
    elif [[ "$trailer_type" == "issue" || "$trailer_type" == "related-to" ]]; then
        # Add comment about the link
        local commit_short=$(git rev-parse --short "$commit")  
        local commit_subject=$(git show --format="%s" -s "$commit")
        add_comment "$issue_id" "Referenced in commit $commit_short: $commit_subject"
    fi
}

# Initialize storage backend before any operations
detect_storage_backend

# Main script logic
case "$1" in
    create)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'create' requires title${NC}"
            echo "Usage: git issue create 'Title' [--description='Description']"
            exit 1
        fi
        create_issue_with_flags "${@:2}"
        ;;
    add)
        # Legacy support - redirect to create
        echo -e "${YELLOW}Note: 'add' is deprecated, use 'create' for auto-generated hash IDs${NC}"
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'add' requires id and title${NC}"
            usage
        fi
        # Manual ID creation (legacy)
        manual_id="$2"
        manual_title="${@:3}"
        if issue_exists "$manual_id"; then
            echo -e "${RED}Issue #$manual_id already exists${NC}"
            exit 1
        fi
        # Create with manual ID
        ref=$(get_issue_ref "$manual_id")
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        author=$(get_git_user)
        cat <<EOF | git notes --ref="$ref" add -F -
id: $manual_id
title: $manual_title
state: open
priority: medium
created: $timestamp
updated: $timestamp
author: $author
assignee: 
hash_source: manual
---
EOF
        echo -e "${GREEN}‚úì Created issue #$manual_id: $manual_title${NC}"
        ;;
    list)
        list_issues
        ;;
    show)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'show' requires issue id${NC}"
            usage
        fi
        
        issue_id="$2"
        show_commits=false
        
        # Check for --with-commits flag
        if [[ "$3" == "--with-commits" ]]; then
            show_commits=true
        fi
        
        # Show issue details
        show_issue "$issue_id"
        
        # Show related commits if requested
        if [[ "$show_commits" == true ]]; then
            echo ""
            echo -e "${BLUE}Related Commits:${NC}"
            related_commits=$(get_related_commits "$issue_id")
            
            if [[ -n "$related_commits" ]]; then
                echo "$related_commits" | while IFS= read -r commit_line; do
                    echo "  $commit_line"
                done
            else
                echo -e "  ${GRAY}No commits found with trailers referencing this issue${NC}"
                echo -e "  ${GRAY}Use 'git issue commit --fixes $issue_id' to link commits${NC}"
            fi
        fi
        ;;
    update)
        if [ $# -lt 2 ]; then
            echo -e "${RED}Error: 'update' requires issue id and flags${NC}"
            echo "Usage: git issue update <id> --state=<state> [--priority=<priority>] [--assignee=<assignee>]"
            exit 1
        fi
        update_issue_with_flags "${@:2}"
        ;;
    comment)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'comment' requires id and text${NC}"
            usage
        fi
        add_comment "$2" "${@:3}"
        ;;
    link)
        if [ $# -lt 3 ]; then
            echo -e "${RED}Error: 'link' requires id and commit${NC}"
            usage
        fi
        link_issue "$2" "$3"
        ;;
    commit)
        shift
        handle_commit_with_trailers "$@"
        ;;
    scan-commits)
        shift
        scan_commits_for_issues "$@"
        ;;
    setup-sync)
        setup_sync "$2"
        ;;
    import)
        shift
        import_issues "$@"
        ;;
    export)
        shift  
        export_issues "$@"
        ;;
    "--help"|"-h"|"help")
        usage
        ;;
    "")
        usage
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
        echo ""
        usage
        exit 1
        ;;
esac

# Clean up XDG environment if needed
cleanup_xdg_environment