#!/bin/bash
# Compile .git-issue/statuses → .git-issue/statuses.bash
# Generates bash case statements for zero-overhead status validation
set -e

input="${1:-.git-issue/statuses}"
output="${input%/*}/statuses.bash"

if [[ ! -f "$input" ]]; then
    echo "Error: $input not found" >&2
    exit 1
fi

# Parse the definition file
statuses=()
colors=()
descriptions=()
transitions=()
mode="permissive"

while IFS= read -r line; do
    # Strip comments and whitespace
    line="${line%%#*}"
    [[ -z "${line// /}" ]] && continue

    if [[ "$line" =~ ^mode:\ *(.+)$ ]]; then
        mode="${BASH_REMATCH[1]// /}"
    elif [[ "$line" =~ ^status:\ *([a-z_]+)\ *\|\ *([a-z]+)\ *\|\ *(.+)$ ]]; then
        statuses+=("${BASH_REMATCH[1]}")
        colors+=("${BASH_REMATCH[2]// /}")
        descriptions+=("${BASH_REMATCH[3]}")
    elif [[ "$line" =~ ^transition:\ *([a-z_]+)\ *→\ *([a-z_]+)$ ]]; then
        transitions+=("${BASH_REMATCH[1]}→${BASH_REMATCH[2]}")
    fi
done < "$input"

if [[ ${#statuses[@]} -eq 0 ]]; then
    echo "Error: no statuses defined in $input" >&2
    exit 1
fi

# Generate the compiled bash file
cat > "$output" << 'HEADER'
# Auto-generated by git-issue-compile-statuses — do not edit
# Source: .git-issue/statuses
HEADER

# STATUSES array
printf 'STATUSES=(' >> "$output"
for s in "${statuses[@]}"; do
    printf '"%s" ' "$s" >> "$output"
done
printf ')\n' >> "$output"

# MODE
printf 'STATUS_MODE="%s"\n\n' "$mode" >> "$output"

# status_color()
printf 'status_color() {\n    case "$1" in\n' >> "$output"
for i in "${!statuses[@]}"; do
    printf '        %s) echo "%s" ;;\n' "${statuses[$i]}" "${colors[$i]}" >> "$output"
done
printf '        *) echo "default" ;;\n' >> "$output"
printf '    esac\n}\n\n' >> "$output"

# status_description()
printf 'status_description() {\n    case "$1" in\n' >> "$output"
for i in "${!statuses[@]}"; do
    printf '        %s) echo "%s" ;;\n' "${statuses[$i]}" "${descriptions[$i]}" >> "$output"
done
printf '        *) echo "" ;;\n' >> "$output"
printf '    esac\n}\n\n' >> "$output"

# validate_transition()
printf 'validate_transition() {\n    local from="$1" to="$2"\n    case "${from}→${to}" in\n' >> "$output"
if [[ ${#transitions[@]} -gt 0 ]]; then
    # Join all transitions with | for a single case pattern
    pattern=""
    for t in "${transitions[@]}"; do
        [[ -n "$pattern" ]] && pattern="${pattern}|"
        pattern="${pattern}${t}"
    done
    printf '        %s) return 0 ;;\n' "$pattern" >> "$output"
fi
printf '        *) return 1 ;;\n' >> "$output"
printf '    esac\n}\n' >> "$output"

echo "Compiled ${#statuses[@]} statuses, ${#transitions[@]} transitions → $output"
